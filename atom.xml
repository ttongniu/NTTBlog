<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>求知若饥 ，虚心若愚</title>
  
  <subtitle>Stay hungry，Stay foolish</subtitle>
  <link href="/NTTBlog/atom.xml" rel="self"/>
  
  <link href="https://ttongniu.github.io/NTTBlog/"/>
  <updated>2019-04-06T14:23:39.897Z</updated>
  <id>https://ttongniu.github.io/NTTBlog/</id>
  
  <author>
    <name>ttongniu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>排序优化</title>
    <link href="https://ttongniu.github.io/NTTBlog/2019/04/06/%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96/"/>
    <id>https://ttongniu.github.io/NTTBlog/2019/04/06/排序优化/</id>
    <published>2019-04-06T14:15:02.000Z</published>
    <updated>2019-04-06T14:23:39.897Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、如何选择最优化的排序算法"><a href="#一、如何选择最优化的排序算法" class="headerlink" title="一、如何选择最优化的排序算法"></a>一、如何选择最优化的排序算法</h2><p><img src="http://upload-images.jianshu.io/upload_images/11332031-052867ec3fe66348.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图表"></p><h3 id="为什选择快速排序？"><a href="#为什选择快速排序？" class="headerlink" title="为什选择快速排序？"></a>为什选择快速排序？</h3><ul><li>线性排序时间复杂度很低但使用场景特殊，如果要写一个通用排序函数，不能选择线性排序。</li><li>为了兼顾任意规模数据的排序，一般会首选时间复杂度为O(nlogn)的排序算法来实现排序函数。</li><li>同为O(nlogn)的快排和归并排序相比，归并排序不是原地排序算法，所以最优的选择是快排。<h2 id="二、如何优化快速排序？"><a href="#二、如何优化快速排序？" class="headerlink" title="二、如何优化快速排序？"></a>二、如何优化快速排序？</h2>导致快排时间复杂度降为O(n)的原因是分区点选择不合理，最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。如何优化分区点的选择？有2种常用方法，如下：<h3 id="1-三数取中法"><a href="#1-三数取中法" class="headerlink" title="1.三数取中法"></a>1.三数取中法</h3></li><li>从区间的首、中、尾分别取一个数，然后比较大小，取中间值作为分区点。</li><li>如果要排序的数组比较大，那“三数取中”可能就不够用了，可能要“5数取中”或者“10数取中”。<h3 id="2-随机法：每次从要排序的区间中，随机选择一个元素作为分区点。"><a href="#2-随机法：每次从要排序的区间中，随机选择一个元素作为分区点。" class="headerlink" title="2.随机法：每次从要排序的区间中，随机选择一个元素作为分区点。"></a>2.随机法：每次从要排序的区间中，随机选择一个元素作为分区点。</h3><h3 id="3-警惕快排的递归发生堆栈溢出，有2中解决方法，如下："><a href="#3-警惕快排的递归发生堆栈溢出，有2中解决方法，如下：" class="headerlink" title="3.警惕快排的递归发生堆栈溢出，有2中解决方法，如下："></a>3.警惕快排的递归发生堆栈溢出，有2中解决方法，如下：</h3></li><li>限制递归深度，一旦递归超过了设置的阈值就停止递归。</li><li>在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈过程，这样就没有系统栈大小的限制。<h2 id="三、通用排序函数实现技巧"><a href="#三、通用排序函数实现技巧" class="headerlink" title="三、通用排序函数实现技巧"></a>三、通用排序函数实现技巧</h2></li><li>数据量不大时，可以采取用时间换空间的思路</li><li>数据量大时，优化快排分区点的选择</li><li>防止堆栈溢出，可以选择在堆上手动模拟调用栈解决</li><li>在排序区间中，当元素个数小于某个常数是，可以考虑使用O(n^2)级别的插入排序</li><li>用哨兵简化代码，每次排序都减少一次判断，尽可能把性能优化到极致<h2 id="四、思考"><a href="#四、思考" class="headerlink" title="四、思考"></a>四、思考</h2><h3 id="1-Java中的排序函数都是用什么排序算法实现的？有有哪些技巧？"><a href="#1-Java中的排序函数都是用什么排序算法实现的？有有哪些技巧？" class="headerlink" title="1.Java中的排序函数都是用什么排序算法实现的？有有哪些技巧？"></a>1.Java中的排序函数都是用什么排序算法实现的？有有哪些技巧？</h3></li><li>答：查看了下Arrays.sort的源码，主要采用TimSort算法, 大致思路是这样的：</li></ul><ol><li>元素个数 &lt; 32, 采用二分查找插入排序(Binary Sort)</li><li>元素个数 &gt;= 32, 采用归并排序，归并的核心是分区(Run)</li><li>找连续升或降的序列作为分区，分区最终被调整为升序后压入栈</li><li>如果分区长度太小，通过二分插入排序扩充分区长度到分区最小阙值</li><li>每次压入栈，都要检查栈内已存在的分区是否满足合并条件，满足则进行合并</li><li>最终栈内的分区被全部合并，得到一个排序好的数组<h3 id="Timsort的合并算法非常巧妙："><a href="#Timsort的合并算法非常巧妙：" class="headerlink" title="Timsort的合并算法非常巧妙："></a>Timsort的合并算法非常巧妙：</h3></li><li>找出左分区最后一个元素(最大)及在右分区的位置</li><li>找出右分区第一个元素(最小)及在左分区的位置</li><li>仅对这两个位置之间的元素进行合并，之外的元素本身就是有序的</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、如何选择最优化的排序算法&quot;&gt;&lt;a href=&quot;#一、如何选择最优化的排序算法&quot; class=&quot;headerlink&quot; title=&quot;一、如何选择最优化的排序算法&quot;&gt;&lt;/a&gt;一、如何选择最优化的排序算法&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://uploa
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://ttongniu.github.io/NTTBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://ttongniu.github.io/NTTBlog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序--下篇</title>
    <link href="https://ttongniu.github.io/NTTBlog/2019/04/06/%E6%8E%92%E5%BA%8F-%E4%B8%8B%E7%AF%87/"/>
    <id>https://ttongniu.github.io/NTTBlog/2019/04/06/排序-下篇/</id>
    <published>2019-04-06T14:14:42.000Z</published>
    <updated>2019-04-06T14:23:01.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、线性排序算法介绍"><a href="#一、线性排序算法介绍" class="headerlink" title="一、线性排序算法介绍"></a>一、线性排序算法介绍</h2><ul><li>线性排序算法包括桶排序、计数排序、基数排序。</li><li>线性排序算法的时间复杂度为O(n)。</li><li>此3种排序算法都不涉及元素之间的比较操作，是非基于比较的排序算法。</li><li>对排序数据的要求很苛刻，重点掌握此3种排序算法的适用场景。<h2 id="二、桶排序（Bucket-sort）"><a href="#二、桶排序（Bucket-sort）" class="headerlink" title="二、桶排序（Bucket sort）"></a>二、桶排序（Bucket sort）</h2><h3 id="1-算法原理："><a href="#1-算法原理：" class="headerlink" title="1.算法原理："></a>1.算法原理：</h3></li><li>将要排序的### 数据分到几个有序的桶里，每个桶里的数据再单独进行快速排序。</li><li>桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。<br><img src="http://upload-images.jianshu.io/upload_images/11332031-1b856abf6d33064b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="桶排序"><h3 id="2-使用条件"><a href="#2-使用条件" class="headerlink" title="2.使用条件"></a>2.使用条件</h3></li><li>要排序的数据需要很容易就能划分成m个桶，并且桶与桶之间有着天然的大小顺序。</li><li>数据在各个桶之间分布是均匀的。<h3 id="3-适用场景"><a href="#3-适用场景" class="headerlink" title="3.适用场景"></a>3.适用场景</h3></li><li>桶排序比较适合用在外部排序中。</li><li>外部排序就是数据存储在外部磁盘且数据量大，但内存有限无法将整个数据全部加载到内存中。<h3 id="4-应用案例"><a href="#4-应用案例" class="headerlink" title="4.应用案例"></a>4.应用案例</h3></li><li>需求描述：<br>有10GB的订单数据，需按订单金额（假设金额都是正整数）进行排序<br>但内存有限，仅几百MB</li><li>解决思路：<br>扫描一遍文件，看订单金额所处数据范围，比如1元-10万元，那么就分100个桶。<br>第一个桶存储金额1-1000元之内的订单，第二个桶存1001-2000元之内的订单，依次类推。<br>每个桶对应一个文件，并按照金额范围的大小顺序编号命名（00，01，02，…，99）。<br>将100个小文件依次放入内存并用快排排序。<br>所有文件排好序后，只需按照文件编号从小到大依次读取每个小文件并写到大文件中即可。</li><li>注意点：若单个文件无法全部载入内存，则针对该文件继续按照前面的思路进行处理即可。<h2 id="三、计数排序（Counting-sort）"><a href="#三、计数排序（Counting-sort）" class="headerlink" title="三、计数排序（Counting sort）"></a>三、计数排序（Counting sort）</h2><h3 id="1-算法原理"><a href="#1-算法原理" class="headerlink" title="1.算法原理"></a>1.算法原理</h3></li><li>计数其实就是桶排序的一种特殊情况。</li><li>当要排序的n个数据所处范围并不大时，比如最大值为k，则分成k个桶</li><li>每个桶内的数据值都是相同的，就省掉了桶内排序的时间。<h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 计数排序，a 是数组，n 是数组大小。假设数组中存储的都是非负整数。</span><br><span class="line">public void countingSort(int[] a, int n) &#123;</span><br><span class="line">  if (n &lt;= 1) return;</span><br><span class="line"></span><br><span class="line">  // 查找数组中数据的范围</span><br><span class="line">  int max = a[0];</span><br><span class="line">  for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">    if (max &lt; a[i]) &#123;</span><br><span class="line">      max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int[] c = new int[max + 1]; // 申请一个计数数组 c，下标大小 [0,max]</span><br><span class="line">  for (int i = 0; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 计算每个元素的个数，放入 c 中</span><br><span class="line">  for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">    c[a[i]]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 依次累加</span><br><span class="line">  for (int i = 1; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = c[i-1] + c[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 临时数组 r，存储排序之后的结果</span><br><span class="line">  int[] r = new int[n];</span><br><span class="line">  // 计算排序的关键步骤，有点难理解</span><br><span class="line">  for (int i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">    int index = c[a[i]]-1;</span><br><span class="line">    r[index] = a[i];</span><br><span class="line">    c[a[i]]--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 将结果拷贝给 a 数组</span><br><span class="line">  for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">    a[i] = r[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>案例分析：<br>假设只有8个考生分数在0-5分之间，成绩存于数组A[8] = [2，5，3，0，2，3，0，3]。<br>使用大小为6的数组C[6]表示桶，下标对应分数，即0，1，2，3，4，5。<br>C[6]存储的是考生人数，只需遍历一边考生分数，就可以得到C[6] = [2，0，2，3，0，1]。<br>对C[6]数组顺序求和则C[6]=[2，2，4，7，7，8]，c[k]存储的是小于等于分数k的考生个数。<br>数组R[8] = [0，0，2，2，3，3，3，5]存储考生名次。那么如何得到R[8]的呢？<br>从后到前依次扫描数组A，比如扫描到3时，可以从数组C中取出下标为3的值7，也就是说，到目前为止，包括自己在内，分数小于等于3的考生有7个，也就是说3是数组R的第7个元素（也就是数组R中下标为6的位置）。当3放入数组R后，小于等于3的元素就剩下6个了，相应的C[3]要减1变成6。<br>以此类推，当扫描到第二个分数为3的考生时，就会把它放入数组R中第6个元素的位置（也就是下标为5的位置）。当扫描完数组A后，数组R内的数据就是按照分数从小到大排列的了。</p><h3 id="3-使用条件"><a href="#3-使用条件" class="headerlink" title="3.使用条件"></a>3.使用条件</h3><ul><li>只能用在数据范围不大的场景中，若数据范围k比要排序的数据n大很多，就不适合用计数排序；</li><li>计数排序只能给非负整数排序，其他类型需要在不改变相对大小情况下，转换为非负整数；</li><li>比如如果考试成绩精确到小数后一位，就需要将所有分数乘以10，转换为整数。<h2 id="四、基数排序（Radix-sort）"><a href="#四、基数排序（Radix-sort）" class="headerlink" title="四、基数排序（Radix sort）"></a>四、基数排序（Radix sort）</h2><h3 id="1-算法原理（以排序10万个手机号为例来说明）"><a href="#1-算法原理（以排序10万个手机号为例来说明）" class="headerlink" title="1.算法原理（以排序10万个手机号为例来说明）"></a>1.算法原理（以排序10万个手机号为例来说明）</h3></li><li>比较两个手机号码a，b的大小，如果在前面几位中a已经比b大了，那后面几位就不用看了。</li><li>借助稳定排序算法的思想，可以先按照最后一位来排序手机号码，然后再按照倒数第二位来重新排序，以此类推，最后按照第一个位重新排序。</li><li>经过11次排序后，手机号码就变为有序的了。</li><li>每次排序有序数据范围较小，可以使用桶排序或计数排序来完成。<h3 id="2-使用条件-1"><a href="#2-使用条件-1" class="headerlink" title="2.使用条件"></a>2.使用条件</h3></li><li>要求数据可以分割独立的“位”来比较；</li><li>位之间由递进关系，如果a数据的高位比b数据大，那么剩下的地位就不用比较了；</li><li>每一位的数据范围不能太大，要可以用线性排序，否则基数排序的时间复杂度无法做到O(n)。<h2 id="五、思考"><a href="#五、思考" class="headerlink" title="五、思考"></a>五、思考</h2></li><li>1.如何根据年龄给100万用户数据排序？<ul><li>答：利用桶排序。</li></ul></li><li>2.对D，a，F，B，c，A，z这几个字符串进行排序，要求将其中所有小写字母都排在大写字母前面，但是小写字母内部和大写字母内部不要求有序。比如<br>经过排序后为a，c，z，D，F，B，A，这个如何实现呢？如果字符串中处理大小写，还有数字，将数字放在最前面，又该如何解决呢？</li><li>答：用两个指针a、b：a指针从头开始往后遍历，遇到大写字母就停下，b从后往前遍历，遇到小写字母就停下，交换a、b指针对应的元素；重复如上过程，直到a、b指针相交。<br>对于小写字母放前面，数字放中间，大写字母放后面，可以先将数据分为小写字母和非小写字母两大类，进行如上交换后再在非小写字母区间内分为数字和大写字母做同样处理</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、线性排序算法介绍&quot;&gt;&lt;a href=&quot;#一、线性排序算法介绍&quot; class=&quot;headerlink&quot; title=&quot;一、线性排序算法介绍&quot;&gt;&lt;/a&gt;一、线性排序算法介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;线性排序算法包括桶排序、计数排序、基数排序。&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://ttongniu.github.io/NTTBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://ttongniu.github.io/NTTBlog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序--中篇</title>
    <link href="https://ttongniu.github.io/NTTBlog/2019/04/06/%E6%8E%92%E5%BA%8F-%E4%B8%AD%E7%AF%87/"/>
    <id>https://ttongniu.github.io/NTTBlog/2019/04/06/排序-中篇/</id>
    <published>2019-04-06T14:14:20.000Z</published>
    <updated>2019-04-06T14:21:52.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>快排的思想是这样的：如果要排序数组中下标从p到r之间的一组数据，我们选择p到r之间的任意一个数据作为pivot（分区点）。然后遍历p到r之间的数据，将小于pivot的放到左边，将大于pivot的放到右边，将povit放到中间。经过这一步之后，数组p到r之间的数据就分成了3部分，前面p到q-1之间都是小于povit的，中间是povit，后面的q+1到r之间是大于povit的。根据分治、递归的处理思想，我们可以用递归排序下标从p到q-1之间的数据和下标从q+1到r之间的数据，直到区间缩小为1，就说明所有的数据都有序了。</p><ul><li>递推公式：quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)</li><li>终止条件：p &gt;= r<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="算法稳定性："><a href="#算法稳定性：" class="headerlink" title="算法稳定性："></a>算法稳定性：</h3>因为分区过程中涉及交换操作，如果数组中有两个8，其中一个是pivot，经过分区处理后，后面的8就有可能放到了另一个8的前面，先后顺序就颠倒了，所以快速排序是不稳定的排序算法。比如数组[1,2,3,9,8,11,8]，取后面的8作为pivot，那么分区后就会将后面的8与9进行交换。<h3 id="时间复杂度：最好、最坏、平均情况"><a href="#时间复杂度：最好、最坏、平均情况" class="headerlink" title="时间复杂度：最好、最坏、平均情况"></a>时间复杂度：最好、最坏、平均情况</h3>快排也是用递归实现的，所以时间复杂度也可以用递推公式表示。<br>如果每次分区操作都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并的相同。<br>T(1) = C； n=1 时，只需要常量级的执行时间，所以表示为 C。<br>T(n) = 2*T(n/2) + n； n&gt;1<br>所以，快排的时间复杂度也是O(nlogn)。<br>如果数组中的元素原来已经有序了，比如1，3，5，6，8，若每次选择最后一个元素作为pivot，那每次分区得到的两个区间都是不均等的，需要进行大约n次的分区，才能完成整个快排过程，而每次分区我们平均要扫描大约n/2个元素，这种情况下，快排的时间复杂度就是O(n^2)。<br>前面两种情况，一个是分区及其均衡，一个是分区极不均衡，它们分别对应了快排的最好情况时间复杂度和最坏情况时间复杂度。那快排的平均时间复杂度是多少呢？T(n)大部分情况下是O(nlogn)，只有在极端情况下才是退化到O(n^2)，而且我们也有很多方法将这个概率降低。<h3 id="空间复杂度：快排是一种原地排序算法，空间复杂度是O-1"><a href="#空间复杂度：快排是一种原地排序算法，空间复杂度是O-1" class="headerlink" title="空间复杂度：快排是一种原地排序算法，空间复杂度是O(1)"></a>空间复杂度：快排是一种原地排序算法，空间复杂度是O(1)</h3><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2>快速排序 –利用的哨兵<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static void quickSort(int[] a, int head, int tail) &#123;</span><br><span class="line"></span><br><span class="line">int low = head;</span><br><span class="line">int high = tail;</span><br><span class="line">int pivot = a[low];</span><br><span class="line">if (low &lt; high) &#123;</span><br><span class="line"></span><br><span class="line">while (low&lt;high) &#123;</span><br><span class="line">while (low &lt; high &amp;&amp; pivot &lt;= a[high]) high--;</span><br><span class="line">a[low] = a[high];</span><br><span class="line">while (low &lt; high &amp;&amp; pivot &gt;= a[low]) low++;</span><br><span class="line">a[high]=a[low];</span><br><span class="line">&#125;</span><br><span class="line">a[low] = pivot;</span><br><span class="line"></span><br><span class="line">if(low&gt;head+1) quickSort(a,head,low-1);</span><br><span class="line">if(high&lt;tail-1) quickSort(a,high+1,tail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>// 归并排序算法, a是数组，n表示数组大小<br><figure class="highlight plain"><figcaption><span>static void mergeSort(int[] a, int n) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  mergeSortInternally(a, 0, n-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 递归调用函数</span><br><span class="line">private static void mergeSortInternally(int[] a, int p, int r) &#123;</span><br><span class="line">  // 递归终止条件</span><br><span class="line">  if (p &gt;= r) return;</span><br><span class="line"></span><br><span class="line">  // 取p到r之间的中间位置q,防止（p+r）的和超过int类型最大值</span><br><span class="line">  int q = p + (r - p)/2;</span><br><span class="line">  // 分治递归</span><br><span class="line">  mergeSortInternally(a, p, q);</span><br><span class="line">  mergeSortInternally(a, q+1, r);</span><br><span class="line"></span><br><span class="line">  // 将A[p...q]和A[q+1...r]合并为A[p...r]</span><br><span class="line">  merge(a, p, q, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void merge(int[] a, int p, int q, int r) &#123;</span><br><span class="line">  int i = p;</span><br><span class="line">  int j = q+1;</span><br><span class="line">  int k = 0; // 初始化变量i, j, k</span><br><span class="line">  int[] tmp = new int[r-p+1]; // 申请一个大小跟a[p...r]一样的临时数组</span><br><span class="line">  while (i&lt;=q &amp;&amp; j&lt;=r) &#123;</span><br><span class="line">    if (a[i] &lt;= a[j]) &#123;</span><br><span class="line">      tmp[k++] = a[i++]; // i++等于i:=i+1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      tmp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 判断哪个子数组中有剩余的数据</span><br><span class="line">  int start = i;</span><br><span class="line">  int end = q;</span><br><span class="line">  if (j &lt;= r) &#123;</span><br><span class="line">    start = j;</span><br><span class="line">    end = r;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 将剩余的数据拷贝到临时数组tmp</span><br><span class="line">  while (start &lt;= end) &#123;</span><br><span class="line">    tmp[k++] = a[start++];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 将tmp中的数组拷贝回a[p...r]</span><br><span class="line">  for (i = 0; i &lt;= r-p; ++i) &#123;</span><br><span class="line">    a[p+i] = tmp[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="归并排序与快速排序的区别"><a href="#归并排序与快速排序的区别" class="headerlink" title="归并排序与快速排序的区别"></a>归并排序与快速排序的区别</h2><p>归并和快排用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢？<br><img src="http://upload-images.jianshu.io/upload_images/11332031-2f457bc581106afc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11"><br>1.归并排序，是先递归调用，再进行合并，合并的时候进行数据的交换。所以它是自下而上的排序方式。何为自下而上？就是先解决子问题，再解决父问题。<br>2.快速排序，是先分区，在递归调用，分区的时候进行数据的交换。所以它是自上而下的排序方式。何为自上而下？就是先解决父问题，再解决子问题。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>O(n)时间复杂度内求无序数组中第K大元素，比如4，2，5，12，3这样一组数据，第3大元素是4。<br>我们选择数组区间A[0…n-1]的最后一个元素作为pivot，对数组A[0…n-1]进行原地分区，这样数组就分成了3部分，A[0…p-1]、A[p]、A[p+1…n-1]。<br>如果如果p+1=K，那A[p]就是要求解的元素；如果K&gt;p+1，说明第K大元素出现在A[p+1…n-1]区间，我们按照上面的思路递归地在A[p+1…n-1]这个区间查找。同理，如果K&lt;p+1，那我们就在A[0…p-1]区间查找。<br>时间复杂度分析？<br>答：第一次分区查找，我们需要对大小为n的数组进行分区操作，需要遍历n个元素。第二次分区查找，我们需要对大小为n/2的数组执行分区操作，需要遍历n/2个元素。依次类推，分区遍历元素的个数分别为n、n/2、n/4、n/8、n/16……直到区间缩小为1。如果把每次分区遍历的元素个数累加起来，就是等比数列求和，结果为2n-1。所以，上述解决问题的思路为O(n)。</li><li>有10个访问日志文件，每个日志文件大小约为300MB，每个文件里的日志都是按照时间戳从小到大排序的。现在需要将这10个较小的日志文件合并为1个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述任务的机器内存只有1GB，你有什么好的解决思路能快速地将这10个日志文件合并？<br>答：先构建十条io流，分别指向十个文件，每条io流读取对应文件的第一条数据，然后比较时间戳，选择出时间戳最小的那条数据，将其写入一个新的文件，然后指向该时间戳的io流读取下一行数据，然后继续刚才的操作，比较选出最小的时间戳数据，写入新文件，io流读取下一行数据，以此类推，完成文件的合并， 这种处理方式，日志文件有n个数据就要比较n次，每次比较选出一条数据来写入，时间复杂度是O（n），空间复杂度是O（1）,几乎不占用内存。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h1&gt;&lt;h2 id=&quot;算法原理&quot;&gt;&lt;a href=&quot;#算法原理&quot; class=&quot;headerlink&quot; title=&quot;算法原理&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://ttongniu.github.io/NTTBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://ttongniu.github.io/NTTBlog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序--上篇</title>
    <link href="https://ttongniu.github.io/NTTBlog/2019/04/06/%E6%8E%92%E5%BA%8F-%E4%B8%8A%E7%AF%87/"/>
    <id>https://ttongniu.github.io/NTTBlog/2019/04/06/排序-上篇/</id>
    <published>2019-04-06T14:13:58.000Z</published>
    <updated>2019-04-06T14:20:41.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序方法与复杂度归类"><a href="#排序方法与复杂度归类" class="headerlink" title="排序方法与复杂度归类"></a>排序方法与复杂度归类</h2><p>（1）几种最经典、最常用的排序方法：冒泡排序、插入排序、选择排序、快速排序、归并排序、计数排序、基数排序、桶排序。<br>（2）复杂度归类<br>冒泡排序、插入排序、选择排序 O(n^2)<br>快速排序、归并排序 O(nlogn)<br>计数排序、基数排序、桶排序 O(n)</p><h2 id="如何分析一个“排序算法”？"><a href="#如何分析一个“排序算法”？" class="headerlink" title="如何分析一个“排序算法”？"></a>如何分析一个“排序算法”？</h2><h3 id="算法的执行效率"><a href="#算法的执行效率" class="headerlink" title="算法的执行效率"></a>算法的执行效率</h3><ol><li>最好、最坏、平均情况时间复杂度。</li><li>时间复杂度的系数、常数和低阶。</li><li>比较次数，交换（或移动）次数。<h3 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h3></li><li>稳定性概念：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</li><li>稳定性重要性：可针对对象的多种属性进行有优先级的排序。</li><li>举例：给电商交易系统中的“订单”排序，按照金额大小对订单数据排序，对于相同金额的订单以下单时间早晚排序。用稳定排序算法可简洁地解决。先按照下单时间给订单排序，排序完成后用稳定排序算法按照订单金额重新排序。<h3 id="排序算法的内存损耗"><a href="#排序算法的内存损耗" class="headerlink" title="排序算法的内存损耗"></a>排序算法的内存损耗</h3>原地排序算法：特指空间复杂度是O(1)的排序算法。</li></ol><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void bubbleSort(int[] a, int n) &#123;</span><br><span class="line">  if (n &lt;= 1) return;</span><br><span class="line"> for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">    // 提前退出冒泡循环的标志位</span><br><span class="line">    boolean flag = false;</span><br><span class="line">    for (int j = 0; j &lt; n - i - 1; ++j) &#123;</span><br><span class="line">      if (a[j] &gt; a[j+1]) &#123; // 交换</span><br><span class="line">        int tmp = a[j];</span><br><span class="line">        a[j] = a[j+1];</span><br><span class="line">        a[j+1] = tmp;</span><br><span class="line">        flag = true;  // 表示有数据交换      </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   if (!flag) break;  // 没有数据交换，提前退出</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让它俩互换。<br>稳定性：冒泡排序是稳定的排序算法。<br>空间复杂度：冒泡排序是原地排序算法。<br>时间复杂度：</p><ol><li>最好情况（满有序度）：O(n)。</li><li>最坏情况（满逆序度）：O(n^2)。</li><li>平均情况：<br>“有序度”和“逆序度”：对于一个不完全有序的数组，如4，5，6，3，2，1，有序元素对为3个（4，5），（4，6），（5，6），有序度为3，逆序度为12；对于一个完全有序的数组，如1，2，3，4，5，6，有序度就是n<em>(n-1)/2，也就是15，称作满有序度；逆序度=满有序度-有序度；冒泡排序、插入排序交换（或移动）次数=逆序度。<br>最好情况下初始有序度为n</em>(n-1)/2，最坏情况下初始有序度为0，则平均初始有序度为n<em>(n-1)/4，即交换次数为n</em>(n-1)/4，因交换次数&lt;比较次数&lt;最坏情况时间复杂度，所以平均时间复杂度为O(n^2)。</li></ol><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> public void insertionSort(int[] a, int n) &#123;</span><br><span class="line">  if (n &lt;= 1) return;</span><br><span class="line">  for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">    int value = a[i];</span><br><span class="line">    int j = i - 1;</span><br><span class="line">    // 查找插入的位置</span><br><span class="line">    for (; j &gt;= 0; --j) &#123;</span><br><span class="line">      if (a[j] &gt; value) &#123;</span><br><span class="line">        a[j+1] = a[j];  // 数据移动</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j+1] = value; // 插入数据</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入排序将数组数据分成已排序区间和未排序区间。初始已排序区间只有一个元素，即数组第一个元素。在未排序区间取出一个元素插入到已排序区间的合适位置，直到未排序区间为空。<br>空间复杂度：插入排序是原地排序算法。<br>时间复杂度：</p><ol><li>最好情况：O(n)。</li><li>最坏情况：O(n^2)。</li><li>平均情况：O(n^2)（往数组中插入一个数的平均时间复杂度是O(n)，一共重复n次）。<br>稳定性：插入排序是稳定的排序算法。</li></ol><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void selectSort(int[] a, int n) &#123;</span><br><span class="line">if(n&lt;=0) return;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">int min=i;</span><br><span class="line">for(int j=i;j&lt;n;j++)&#123;</span><br><span class="line">if(a[j] &lt; a[min]) min=j;</span><br><span class="line">&#125;</span><br><span class="line">if(min != i)&#123;</span><br><span class="line">int temp=a[i];</span><br><span class="line">a[i]=a[min];</span><br><span class="line">a[min]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择排序将数组分成已排序区间和未排序区间。初始已排序区间为空。每次从未排序区间中选出最小的元素插入已排序区间的末尾，直到未排序区间为空。<br>空间复杂度：选择排序是原地排序算法。<br>时间复杂度：（都是O(n^2)）</p><ol><li>最好情况：O(n^2)。</li><li>最坏情况：O(n^2)。</li><li>平均情况：O(n^2)。<br>稳定性：选择排序不是稳定的排序算法。</li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>选择排序和插入排序的时间复杂度相同，都是O(n^2)，在实际的软件开发中，为什么我们更倾向于使用插入排序而不是冒泡排序算法呢？<br>答：从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要3个赋值操作，而插入排序只需要1个，所以在对相同数组进行排序时，冒泡排序的运行时间理论上要长于插入排序。<code></code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;排序方法与复杂度归类&quot;&gt;&lt;a href=&quot;#排序方法与复杂度归类&quot; class=&quot;headerlink&quot; title=&quot;排序方法与复杂度归类&quot;&gt;&lt;/a&gt;排序方法与复杂度归类&lt;/h2&gt;&lt;p&gt;（1）几种最经典、最常用的排序方法：冒泡排序、插入排序、选择排序、快速排序、
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://ttongniu.github.io/NTTBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://ttongniu.github.io/NTTBlog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>递归</title>
    <link href="https://ttongniu.github.io/NTTBlog/2019/04/06/%E9%80%92%E5%BD%92/"/>
    <id>https://ttongniu.github.io/NTTBlog/2019/04/06/递归/</id>
    <published>2019-04-06T14:13:11.000Z</published>
    <updated>2019-04-06T14:17:51.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是递归？"><a href="#什么是递归？" class="headerlink" title="什么是递归？"></a>什么是递归？</h2><ul><li>递归是一种非常高效、简洁的编码技巧，一种应用非常广泛的算法，比如DFS深度优先搜索、前中后序二叉树遍历等都是使用递归。</li><li>方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。</li><li>基本上，所有的递归问题都可以用递推公式来表示。<h2 id="为什么使用递归？递归的优缺点？"><a href="#为什么使用递归？递归的优缺点？" class="headerlink" title="为什么使用递归？递归的优缺点？"></a>为什么使用递归？递归的优缺点？</h2></li><li>优点：代码的表达力很强，写起来简洁。</li><li>缺点：空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用会耗时较多等问题。<h2 id="什么样的问题可以用递归解决呢？"><a href="#什么样的问题可以用递归解决呢？" class="headerlink" title="什么样的问题可以用递归解决呢？"></a>什么样的问题可以用递归解决呢？</h2>一个问题只要同时满足以下3个条件，就可以用递归来解决：<br>1.问题的解可以分解为几个子问题的解。何为子问题？就是数据规模更小的问题。<br>2.问题与子问题，除了数据规模不同，求解思路完全一样<br>3.存在递归终止条件<h2 id="如何实现递归？"><a href="#如何实现递归？" class="headerlink" title="如何实现递归？"></a>如何实现递归？</h2><h3 id="递归代码编写"><a href="#递归代码编写" class="headerlink" title="递归代码编写"></a>递归代码编写</h3>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。<h3 id="递归代码理解"><a href="#递归代码理解" class="headerlink" title="递归代码理解"></a>递归代码理解</h3>对于递归代码，若试图想清楚整个递和归的过程，实际上是进入了一个思维误区。<br>那该如何理解递归代码呢？如果一个问题A可以分解为若干个子问题B、C、D，你可以假设子问题B、C、D已经解决。而且，你只需要思考问题A与子问题B、C、D两层之间的关系即可，不需要一层层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。<br>因此，理解递归代码，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。<h2 id="递归常见问题及解决方案"><a href="#递归常见问题及解决方案" class="headerlink" title="递归常见问题及解决方案"></a>递归常见问题及解决方案</h2></li><li>警惕堆栈溢出：可以声明一个全局变量来控制递归的深度，从而避免堆栈溢出。</li><li>警惕重复计算：通过某种数据结构来保存已经求解过的值，从而避免重复计算。<h2 id="如何将递归改写为非递归代码？"><a href="#如何将递归改写为非递归代码？" class="headerlink" title="如何将递归改写为非递归代码？"></a>如何将递归改写为非递归代码？</h2>笼统的讲，所有的递归代码都可以改写为迭代循环的非递归写法。如何做？抽象出递推公式、初始值和边界条件，然后用迭代循环实现。<h3 id="我们平时调试代码喜欢使用-IDE-的单步跟踪功能，像规模比较大、递归层次很深的递归代码，几乎无法使用这种调试方式。对于递归代码，你有什么好的调试方法呢？"><a href="#我们平时调试代码喜欢使用-IDE-的单步跟踪功能，像规模比较大、递归层次很深的递归代码，几乎无法使用这种调试方式。对于递归代码，你有什么好的调试方法呢？" class="headerlink" title="我们平时调试代码喜欢使用 IDE 的单步跟踪功能，像规模比较大、递归层次很深的递归代码，几乎无法使用这种调试方式。对于递归代码，你有什么好的调试方法呢？"></a>我们平时调试代码喜欢使用 IDE 的单步跟踪功能，像规模比较大、递归层次很深的递归代码，几乎无法使用这种调试方式。对于递归代码，你有什么好的调试方法呢？</h3>调试递归:<br>1.打印日志发现，递归值。<br>2.结合条件断点进行调试。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是递归？&quot;&gt;&lt;a href=&quot;#什么是递归？&quot; class=&quot;headerlink&quot; title=&quot;什么是递归？&quot;&gt;&lt;/a&gt;什么是递归？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;递归是一种非常高效、简洁的编码技巧，一种应用非常广泛的算法，比如DFS深度优先搜索、前中后序二叉
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://ttongniu.github.io/NTTBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://ttongniu.github.io/NTTBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>队列</title>
    <link href="https://ttongniu.github.io/NTTBlog/2019/04/06/%E9%98%9F%E5%88%97/"/>
    <id>https://ttongniu.github.io/NTTBlog/2019/04/06/队列/</id>
    <published>2019-04-06T14:12:46.000Z</published>
    <updated>2019-04-06T14:18:44.565Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是队列？"><a href="#什么是队列？" class="headerlink" title="什么是队列？"></a>什么是队列？</h2><ul><li>先进者先出，这就是典型的“队列”结构。</li><li>支持两个操作：入队enqueue()，放一个数据到队尾；出队dequeue()，从队头取一个元素。</li><li>所以，和栈一样，队列也是一种操作受限的线性表。</li><li>顺序队列<br><img src="http://upload-images.jianshu.io/upload_images/11332031-6322d76ff4fe0e5e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01"> </li><li>链式队列<br><img src="http://upload-images.jianshu.io/upload_images/11332031-cce36c4ebe23fe6f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li><li>循环队列<br><img src="http://upload-images.jianshu.io/upload_images/11332031-30ed9f3108fc3c0f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03"><br>确定好队空和队满的判定条件。<br>队空：head == tail<br>队满：(tail+1)%n=head。<h2 id="队列有哪些常见的应用？"><a href="#队列有哪些常见的应用？" class="headerlink" title="队列有哪些常见的应用？"></a>队列有哪些常见的应用？</h2><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><img src="http://upload-images.jianshu.io/upload_images/11332031-f65c8f30c14166f1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11"></li><li>在队列的基础上增加阻塞操作，就成了阻塞队列。</li><li>阻塞队列就是在队列为空的时候，从队头取数据会被阻塞，因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后在返回。</li><li>从上面的定义可以看出这就是一个“生产者-消费者模型”。这种基于阻塞队列实现的“生产者-消费者模型”可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了，这时生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续生产。不仅如此，基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据处理效率，比如配置几个消费者，来应对一个生产者。<h3 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h3></li><li>在多线程的情况下，会有多个线程同时操作队列，这时就会存在线程安全问题。能够有效解决线程安全问题的队列就称为并发队列。</li><li>并发队列简单的实现就是在enqueue()、dequeue()方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或取操作。</li><li>实际上，基于数组的循环队列利用CAS原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。<h3 id="线程池资源枯竭是的处理"><a href="#线程池资源枯竭是的处理" class="headerlink" title="线程池资源枯竭是的处理"></a>线程池资源枯竭是的处理</h3></li><li>在资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="除了线程池这种池结构会用到队列排队请求，还有哪些类似线程池结构或者场景中会用到队列的排队请求呢？"><a href="#除了线程池这种池结构会用到队列排队请求，还有哪些类似线程池结构或者场景中会用到队列的排队请求呢？" class="headerlink" title="除了线程池这种池结构会用到队列排队请求，还有哪些类似线程池结构或者场景中会用到队列的排队请求呢？"></a>除了线程池这种池结构会用到队列排队请求，还有哪些类似线程池结构或者场景中会用到队列的排队请求呢？</h3>分布式应用中的消息队列，也是一种队列结构</li></ul><h3 id="今天讲到并发队列，关于如何实现无锁的并发队列，网上有很多讨论。对这个问题，你怎么看？"><a href="#今天讲到并发队列，关于如何实现无锁的并发队列，网上有很多讨论。对这个问题，你怎么看？" class="headerlink" title="今天讲到并发队列，关于如何实现无锁的并发队列，网上有很多讨论。对这个问题，你怎么看？"></a>今天讲到并发队列，关于如何实现无锁的并发队列，网上有很多讨论。对这个问题，你怎么看？</h3><p>考虑使用CAS实现无锁队列，则在入队前，获取tail位置，入队时比较tail是否发生变化，如果否，则允许入队，反之，本次入队失败。出队则是获取head位置，进行cas。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是队列？&quot;&gt;&lt;a href=&quot;#什么是队列？&quot; class=&quot;headerlink&quot; title=&quot;什么是队列？&quot;&gt;&lt;/a&gt;什么是队列？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;先进者先出，这就是典型的“队列”结构。&lt;/li&gt;
&lt;li&gt;支持两个操作：入队enqueue()，
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://ttongniu.github.io/NTTBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://ttongniu.github.io/NTTBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>栈</title>
    <link href="https://ttongniu.github.io/NTTBlog/2019/04/06/%E6%A0%88/"/>
    <id>https://ttongniu.github.io/NTTBlog/2019/04/06/栈/</id>
    <published>2019-04-06T14:12:22.000Z</published>
    <updated>2019-04-06T14:17:12.922Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是栈？"><a href="#什么是栈？" class="headerlink" title="什么是栈？"></a>什么是栈？</h2><ul><li>后进者先出，先进者后出，这就是典型的“栈”结构。</li><li>从栈的操作特性来看，是一种“操作受限”的线性表，只允许在端插入和删除数据。<h2 id="为什么需要栈？"><a href="#为什么需要栈？" class="headerlink" title="为什么需要栈？"></a>为什么需要栈？</h2>栈是一种操作受限的数据结构，其操作特性用数组和链表均可实现。但，任何数据结构都是对特定应用场景的抽象，数组和链表虽然使用起来更加灵活，但却暴露了几乎所有的操作，难免会引发错误操作的风险。所以，当某个数据集合只涉及在某端插入和删除数据，且满足后进者先出，先进者后出的操作特性时，我们应该首选栈这种数据结构。<h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2></li><li>栈在函数调用中的应用<br>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构，用来存储函数调用时的临时变量。每进入一个函数，就会将其中的临时变量作为栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">   int a = 1; </span><br><span class="line">   int ret = 0;</span><br><span class="line">   int res = 0;</span><br><span class="line">   ret = add(3, 5);</span><br><span class="line">   res = a + ret;</span><br><span class="line">   printf(&quot;%d&quot;, res);</span><br><span class="line">   reuturn 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int add(int x, int y) &#123;</span><br><span class="line">   int sum = 0;</span><br><span class="line">   sum = x + y;</span><br><span class="line">   return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/11332031-a3396b93fd94a7b0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01"></p><ul><li><p>栈在表达式求值中的应用（比如：34+13*9+44-12/3）<br>利用两个栈，其中一个用来保存操作数，另一个用来保存运算符。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较，若比运算符栈顶元素优先级高，就将当前运算符压入栈，若比运算符栈顶元素的优先级低或者相同，从运算符栈中取出栈顶运算符，从操作数栈顶取出2个操作数，然后进行计算，把计算完的结果压入操作数栈，继续比较。<br><img src="http://upload-images.jianshu.io/upload_images/11332031-a44a72806bae5be1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02"></p></li><li><p>栈在括号匹配中的应用（比如：{}{<a href>()</a>}）<br>用栈保存为匹配的左括号，从左到右一次扫描字符串，当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号，如果能匹配上，则继续扫描剩下的字符串。如果扫描过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。<br>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明未匹配的左括号为非法格式。</p></li><li>如何实现浏览器的前进后退功能？<br>我们使用两个栈X和Y，我们把首次浏览的页面依次压如栈X，当点击后退按钮时，再依次从栈X中出栈，并将出栈的数据一次放入Y栈。当点击前进按钮时，我们依次从栈Y中取出数据，放入栈X中。当栈X中没有数据时，说明没有页面可以继续后退浏览了。当Y栈没有数据，那就说明没有页面可以点击前进浏览了。</li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="我们在讲栈的应用时，讲到用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？"><a href="#我们在讲栈的应用时，讲到用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？" class="headerlink" title="我们在讲栈的应用时，讲到用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？"></a>我们在讲栈的应用时，讲到用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？</h3><p>其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。<br>从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。</p><h3 id="我们都知道，JVM-内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储-Java-中的对象。那-JVM-里面的“栈”跟我们这里说的“栈”是不是一回事呢？如果不是，那它为什么又叫作“栈”呢？"><a href="#我们都知道，JVM-内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储-Java-中的对象。那-JVM-里面的“栈”跟我们这里说的“栈”是不是一回事呢？如果不是，那它为什么又叫作“栈”呢？" class="headerlink" title="我们都知道，JVM 内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储 Java 中的对象。那 JVM 里面的“栈”跟我们这里说的“栈”是不是一回事呢？如果不是，那它为什么又叫作“栈”呢？"></a>我们都知道，JVM 内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储 Java 中的对象。那 JVM 里面的“栈”跟我们这里说的“栈”是不是一回事呢？如果不是，那它为什么又叫作“栈”呢？</h3><p>内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。<br>内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。<br>代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。<br>静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。<br>栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。<br>堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是栈？&quot;&gt;&lt;a href=&quot;#什么是栈？&quot; class=&quot;headerlink&quot; title=&quot;什么是栈？&quot;&gt;&lt;/a&gt;什么是栈？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;后进者先出，先进者后出，这就是典型的“栈”结构。&lt;/li&gt;
&lt;li&gt;从栈的操作特性来看，是一种“操作受限
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://ttongniu.github.io/NTTBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://ttongniu.github.io/NTTBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>IDEA 插件个人常用总结</title>
    <link href="https://ttongniu.github.io/NTTBlog/2019/04/05/IDEA-%E6%8F%92%E4%BB%B6%E4%B8%AA%E4%BA%BA%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://ttongniu.github.io/NTTBlog/2019/04/05/IDEA-插件个人常用总结/</id>
    <published>2019-04-05T15:46:49.000Z</published>
    <updated>2019-04-05T15:48:41.904Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/11332031-561a7ba2c3d91858.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="插件上篇"><br><img src="https://upload-images.jianshu.io/upload_images/11332031-9766609508ff6714.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="插件下篇"><br>包含idea美化 、代码的检验、热部署、Json 转换   、翻译等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/11332031-561a7ba2c3d91858.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
      
    
    </summary>
    
      <category term="Java" scheme="https://ttongniu.github.io/NTTBlog/categories/Java/"/>
    
    
      <category term="IDEA" scheme="https://ttongniu.github.io/NTTBlog/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>链表--下篇</title>
    <link href="https://ttongniu.github.io/NTTBlog/2019/04/05/%E9%93%BE%E8%A1%A8-%E4%B8%8B%E7%AF%87/"/>
    <id>https://ttongniu.github.io/NTTBlog/2019/04/05/链表-下篇/</id>
    <published>2019-04-05T15:06:01.000Z</published>
    <updated>2019-04-05T15:08:41.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何轻松写出正确的链表代码？"><a href="#如何轻松写出正确的链表代码？" class="headerlink" title="如何轻松写出正确的链表代码？"></a>如何轻松写出正确的链表代码？</h1><h2 id="理解指针或引用的含义"><a href="#理解指针或引用的含义" class="headerlink" title="理解指针或引用的含义"></a>理解指针或引用的含义</h2><p>1.含义：将某个变量（对象）赋值给指针（引用），实际上就是就是将这个变量（对象）的地址赋值给指针（引用）。<br>2.示例：<br>p—&gt;next = q; 表示p节点的后继指针存储了q节点的内存地址。<br>p—&gt;next = p—&gt;next—&gt;next; 表示p节点的后继指针存储了p节点的下下个节点的内存地址。</p><h2 id="警惕指针丢失和内存泄漏（单链表）"><a href="#警惕指针丢失和内存泄漏（单链表）" class="headerlink" title="警惕指针丢失和内存泄漏（单链表）"></a>警惕指针丢失和内存泄漏（单链表）</h2><p>1.插入节点<br><img src="http://upload-images.jianshu.io/upload_images/11332031-91f06bb1fb30dd98.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="插入"><br>在节点a和节点b之间插入节点x，b是a的下一节点，，p指针指向节点a，则造成指针丢失和内存泄漏的代码：p—&gt;next = x;x—&gt;next = p—&gt;next; 显然这会导致x节点的后继指针指向自身。<br>正确的写法是2句代码交换顺序，即：x—&gt;next = p—&gt;next; p—&gt;next = x;<br>2.删除节点<br>在节点a和节点b之间删除节点b，b是a的下一节点，p指针指向节点a：p—&gt;next = p—&gt;next—&gt;next;</p><h2 id="利用“哨兵”简化实现难度"><a href="#利用“哨兵”简化实现难度" class="headerlink" title="利用“哨兵”简化实现难度"></a>利用“哨兵”简化实现难度</h2><h3 id="什么是“哨兵”？"><a href="#什么是“哨兵”？" class="headerlink" title="什么是“哨兵”？"></a>什么是“哨兵”？</h3><p>链表中的“哨兵”节点是解决边界问题的，不参与业务逻辑。如果我们引入“哨兵”节点，则不管链表是否为空，head指针都会指向这个“哨兵”节点。我们把这种有“哨兵”节点的链表称为带头链表，相反，没有“哨兵”节点的链表就称为不带头链表。</p><h3 id="未引入“哨兵”的情况"><a href="#未引入“哨兵”的情况" class="headerlink" title="未引入“哨兵”的情况"></a>未引入“哨兵”的情况</h3><p>如果在p节点后插入一个节点，只需2行代码即可搞定：<br>new_node—&gt;next = p—&gt;next;<br>p—&gt;next = new_node;<br>但，若向空链表中插入一个节点，则代码如下：<br>if(head == null){<br>head = new_node;<br>}<br>如果要删除节点p的后继节点，只需1行代码即可搞定：<br>p—&gt;next = p—&gt;next—&gt;next;<br>但，若是删除链表的最有一个节点（链表中只剩下这个节点），则代码如下：<br>if(head—&gt;next == null){<br>head = null;<br>}<br>从上面的情况可以看出，针对链表的插入、删除操作，需要对插入第一个节点和删除最后一个节点的情况进行特殊处理。这样代码就会显得很繁琐，所以引入“哨兵”节点来解决这个问题。</p><h3 id="引入“哨兵”的情况"><a href="#引入“哨兵”的情况" class="headerlink" title="引入“哨兵”的情况"></a>引入“哨兵”的情况</h3><p>“哨兵”节点不存储数据，无论链表是否为空，head指针都会指向它，作为链表的头结点始终存在。这样，插入第一个节点和插入其他节点，删除最后一个节点和删除其他节点都可以统一为相同的代码实现逻辑了。</p><h3 id="4-“哨兵”还有哪些应用场景？"><a href="#4-“哨兵”还有哪些应用场景？" class="headerlink" title="4.“哨兵”还有哪些应用场景？"></a>4.“哨兵”还有哪些应用场景？</h3><p>哨兵最大的作用就是简化边界条件的处理。<br>对于双向链表 L（L.head 为表头，表头有值，L.head.prev 为 NIL），L.nil 作为该链表的哨兵变量，<br>L.nil.next 指向表头；<br>L.nil.prev 指向表尾；</p><ul><li>不含哨兵的链表（头）插入：<br><code>LIST_INSERT(L, x)x.next = L.headif L.head != NIL  L.head.prev = xL.head = xx.prev = NIL</code></li><li>使用哨兵之后便可以省去条件判断语句：<br><code>LIST_INSERT&#39;(L, x)x.next = L.nil.nextL.nil.next.prev = xL.nil.next = xx.prev = L.nil</code><h2 id="重点留意边界条件处理"><a href="#重点留意边界条件处理" class="headerlink" title="重点留意边界条件处理"></a>重点留意边界条件处理</h2>经常用来检查链表是否正确的边界4个边界条件：</li><li>如果链表为空时，代码是否能正常工作？</li><li>如果链表只包含一个节点时，代码是否能正常工作？</li><li>如果链表只包含两个节点时，代码是否能正常工作？</li><li>代码逻辑在处理头尾节点时是否能正常工作？</li></ul><h2 id="举例画图，辅助思考"><a href="#举例画图，辅助思考" class="headerlink" title="举例画图，辅助思考"></a>举例画图，辅助思考</h2><p><img src="http://upload-images.jianshu.io/upload_images/11332031-f6e345bf30c7fc5d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="手画"><br>核心思想：释放脑容量，留更多的给逻辑思考，这样就会感觉到思路清晰很多。</p><h2 id="多写多练，没有捷径"><a href="#多写多练，没有捷径" class="headerlink" title="多写多练，没有捷径"></a>多写多练，没有捷径</h2><p>5个常见的链表操作：</p><ul><li>单链表反转</li><li>链表中环的检测</li><li>两个有序链表合并</li><li>删除链表倒数第n个节点</li><li>求链表的中间节点</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;如何轻松写出正确的链表代码？&quot;&gt;&lt;a href=&quot;#如何轻松写出正确的链表代码？&quot; class=&quot;headerlink&quot; title=&quot;如何轻松写出正确的链表代码？&quot;&gt;&lt;/a&gt;如何轻松写出正确的链表代码？&lt;/h1&gt;&lt;h2 id=&quot;理解指针或引用的含义&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://ttongniu.github.io/NTTBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://ttongniu.github.io/NTTBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>链表--上篇</title>
    <link href="https://ttongniu.github.io/NTTBlog/2019/04/05/%E9%93%BE%E8%A1%A8-%E4%B8%8A%E7%AF%87/"/>
    <id>https://ttongniu.github.io/NTTBlog/2019/04/05/链表-上篇/</id>
    <published>2019-04-05T15:05:47.000Z</published>
    <updated>2019-04-05T15:11:52.892Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是链表？"><a href="#什么是链表？" class="headerlink" title="什么是链表？"></a>什么是链表？</h2><ol><li>和数组一样，链表也是一种线性表。</li><li>从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构。</li><li>链表中的每一个内存块被称为节点Node。节点除了存储数据外，还需记录链上下一个节点的地址，即后继指针next。<h2 id="为什么使用链表？即链表的特点"><a href="#为什么使用链表？即链表的特点" class="headerlink" title="为什么使用链表？即链表的特点"></a>为什么使用链表？即链表的特点</h2>1.插入、删除数据效率高O(1)级别（只需更改指针指向即可），随机访问效率低O(n)级别（需要从链头至链尾进行遍历）。<br>2.和数组相比，内存空间消耗更大，因为每个存储数据的节点都需要额外的空间存储后继指针。<h2 id="常用链表：单链表、循环链表和双向链表"><a href="#常用链表：单链表、循环链表和双向链表" class="headerlink" title="常用链表：单链表、循环链表和双向链表"></a>常用链表：单链表、循环链表和双向链表</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><img src="http://upload-images.jianshu.io/upload_images/11332031-cf03b5144eae5e36.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单链表"></li><li>每个节点只包含一个指针，即后继指针。</li><li>单链表有两个特殊的节点，即首节点和尾节点。为什么特殊？用首节点地址表示整条链表，尾节点的后继指针指向空地址null。</li><li>性能特点：插入和删除节点的时间复杂度为O（1），查找的时间复杂度为O(n)。<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><img src="http://upload-images.jianshu.io/upload_images/11332031-8981737b50fe66f3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="循环列表"></li><li>除了尾节点的后继指针指向首节点的地址外均与单链表一致。</li><li>适用于存储有循环特点的数据，比如约瑟夫问题。<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><img src="http://upload-images.jianshu.io/upload_images/11332031-c71148799b78b5f1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="双向列表"></li><li>节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针prev）和下一个节点地址（后继指针next）。</li><li>首节点的前驱指针prev和尾节点的后继指针均指向空地址。</li><li>性能特点：<br>和单链表相比，存储相同的数据，需要消耗更多的存储空间。<br>插入、删除操作比单链表效率更高O(1)级别。以删除操作为例，删除操作分为2种情况：给定数据值删除对应节点和给定节点地址删除节点。对于前一种情况，单链表和双向链表都需要从头到尾进行遍历从而找到对应节点进行删除，时间复杂度为O(n)。对于第二种情况，要进行删除操作必须找到前驱节点，单链表需要从头到尾进行遍历直到p-&gt;next = q，时间复杂度为O(n)，而双向链表可以直接找到前驱节点，时间复杂度为O(1)。<br>对于一个有序链表，双向链表的按值查询效率要比单链表高一些。因为我们可以记录上次查找的位置p，每一次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。<h3 id="双向循环链表：首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点。"><a href="#双向循环链表：首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点。" class="headerlink" title="双向循环链表：首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点。"></a>双向循环链表：首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点。</h3><img src="http://upload-images.jianshu.io/upload_images/11332031-15f5b4c0c98971cc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="双向循环列表"><h2 id="选择数组还是链表？"><a href="#选择数组还是链表？" class="headerlink" title="选择数组还是链表？"></a>选择数组还是链表？</h2><h3 id="插入、删除和随机访问的时间复杂度"><a href="#插入、删除和随机访问的时间复杂度" class="headerlink" title="插入、删除和随机访问的时间复杂度"></a>插入、删除和随机访问的时间复杂度</h3><img src="http://upload-images.jianshu.io/upload_images/11332031-c5c159a73557be90.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="比较"><br>数组：插入、删除的时间复杂度是O(n)，随机访问的时间复杂度是O(1)。<br>链表：插入、删除的时间复杂度是O(1)，随机访问的时间复杂端是O(n)。<h3 id="数组缺点"><a href="#数组缺点" class="headerlink" title="数组缺点"></a>数组缺点</h3></li></ol><ul><li>若申请内存空间很大，比如100M，但若内存空间没有100M的连续空间时，则会申请失败，尽管内存可用空间超过100M。</li><li>大小固定，若存储空间不足，需进行扩容，一旦扩容就要进行数据复制，而这时非常费时的。<h3 id="链表缺点"><a href="#链表缺点" class="headerlink" title="链表缺点"></a>链表缺点</h3></li><li>内存空间消耗更大，因为需要额外的空间存储指针信息。</li><li>对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，还可能会造成频繁的GC（自动垃圾回收器）操作。<h3 id="如何选择？"><a href="#如何选择？" class="headerlink" title="如何选择？"></a>如何选择？</h3>数组简单易用，在实现上使用连续的内存空间，可以借助CPU的缓冲机制预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读。<br>如果代码对内存的使用非常苛刻，那数组就更适合。</li></ul><h2 id="如何实现LRU缓存淘汰算法"><a href="#如何实现LRU缓存淘汰算法" class="headerlink" title="如何实现LRU缓存淘汰算法?"></a>如何实现LRU缓存淘汰算法?</h2><h2 id="什么是缓存？"><a href="#什么是缓存？" class="headerlink" title="什么是缓存？"></a>什么是缓存？</h2><p>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。</p><h2 id="为什么使用缓存淘汰策略？即缓存的特点"><a href="#为什么使用缓存淘汰策略？即缓存的特点" class="headerlink" title="为什么使用缓存淘汰策略？即缓存的特点"></a>为什么使用缓存淘汰策略？即缓存的特点</h2><p>缓存的大小是有限的，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？就需要用到缓存淘汰策略。</p><h2 id="什么是缓存淘汰策略？"><a href="#什么是缓存淘汰策略？" class="headerlink" title="什么是缓存淘汰策略？"></a>什么是缓存淘汰策略？</h2><p>指的是当缓存被用满时清理数据的优先顺序。</p><h2 id="有哪些缓存淘汰策略？"><a href="#有哪些缓存淘汰策略？" class="headerlink" title="有哪些缓存淘汰策略？"></a>有哪些缓存淘汰策略？</h2><p>常见的3种包括先进先出策略FIFO（First In，First Out）、最少使用策略LFU（Least Frenquently Used）、最近最少使用策略LRU（Least Recently Used）。</p><h2 id="链表实现LRU缓存淘汰策略"><a href="#链表实现LRU缓存淘汰策略" class="headerlink" title="链表实现LRU缓存淘汰策略"></a>链表实现LRU缓存淘汰策略</h2><p>当访问的数据没有存储在缓存的链表中时，直接将数据插入链表表头，时间复杂度为O(1)；当访问的数据存在于存储的链表中时，将该数据对应的节点，插入到链表表头,时间复杂度为O(n)。如果缓存被占满，则从链表尾部的数据开始清理，时间复杂度为O(1)。</p><h2 id="数组实现LRU缓存淘汰策略"><a href="#数组实现LRU缓存淘汰策略" class="headerlink" title="数组实现LRU缓存淘汰策略"></a>数组实现LRU缓存淘汰策略</h2><p>用一个数组来存储数据，给每一个数据项标记一个访问时间戳，每次插入新数据项的时候，先把数组中存在的数据项的时间戳自增，并将新数据项的时间戳置为0并插入到数组中。每次访问数组中的数据项的时候，将被访问的数据项的时间戳置为0。当数组空间已满时，将时间戳最大的数据项淘汰。</p><h2 id="利用链表和hashmap实现LRU缓存淘汰策略"><a href="#利用链表和hashmap实现LRU缓存淘汰策略" class="headerlink" title="利用链表和hashmap实现LRU缓存淘汰策略"></a>利用链表和hashmap实现LRU缓存淘汰策略</h2><p>当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则把该节点移到链表头部，如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节点删除即可。在访问数据的时候，如果数据项在链表中存在，则把该节点移到链表头部，否则返回-1。这样一来在链表尾部的节点就是最近最久未访问的数据项。</p><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>时空替换思想：“用空间换时间” 与 “用时间换空间”<br>当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高，时间复杂度小相对较低的算法和数据结构，缓存就是空间换时间的例子。如果内存比较紧缺，比如代码跑在手机或者单片机上，这时，就要反过来用时间换空间的思路。</p><h2 id="如何判断一个字符串是否是回文字符串的问题。"><a href="#如何判断一个字符串是否是回文字符串的问题。" class="headerlink" title="如何判断一个字符串是否是回文字符串的问题。"></a>如何判断一个字符串是否是回文字符串的问题。</h2><p>思路：<br>1 快慢指针定位中间节点<br>2 从中间节点对后半部分逆序<br>3 前后半部分比较，判断是否为回文<br>4 后半部分逆序复原<br>时间复杂度On, 空间复杂度O1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是链表？&quot;&gt;&lt;a href=&quot;#什么是链表？&quot; class=&quot;headerlink&quot; title=&quot;什么是链表？&quot;&gt;&lt;/a&gt;什么是链表？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;和数组一样，链表也是一种线性表。&lt;/li&gt;
&lt;li&gt;从内存结构来看，链表的内存结构是不连续的内存
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://ttongniu.github.io/NTTBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://ttongniu.github.io/NTTBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="https://ttongniu.github.io/NTTBlog/2019/04/05/%E6%95%B0%E7%BB%84/"/>
    <id>https://ttongniu.github.io/NTTBlog/2019/04/05/数组/</id>
    <published>2019-04-05T15:04:42.000Z</published>
    <updated>2019-04-05T15:07:11.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组如何实现随机访问"><a href="#数组如何实现随机访问" class="headerlink" title="数组如何实现随机访问"></a>数组如何实现随机访问</h2><ul><li>数组是一种线性数据结构，用连续的存储空间存储相同类型数据</li><li>线性表：数组、链表、队列、栈<br>   <img src="http://upload-images.jianshu.io/upload_images/11332031-11d1c2a6b814ad94.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线性表"></li><li>非线性表：树 图<br>   <img src="http://upload-images.jianshu.io/upload_images/11332031-7803727b5fe76d60.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="非线性表"></li><li>连续的内存空间、相同的数据，所以数组可以随机访问，但对数组进行删除插入，为了保证数组的连续性，就要做大量的数据搬移工作<h2 id="数组如何实现下标随机访问。"><a href="#数组如何实现下标随机访问。" class="headerlink" title="数组如何实现下标随机访问。"></a>数组如何实现下标随机访问。</h2></li><li>引入数组再内存种的分配图，得出寻址公式</li><li><code>a[i]_address = base_address + i * data_type_size</code></li><li>纠正数组和链表的错误认识。数组的查找操作时间复杂度并不是O(1)。 即便是排好的数组，用二分查找，时间复杂度也是O（logn）。</li><li><p>正确表述：数组支持随机访问，根据下标随机访问的时间复杂度为O（1）</p><h2 id="低效的插入和删除"><a href="#低效的插入和删除" class="headerlink" title="低效的插入和删除"></a>低效的插入和删除</h2></li><li>插入：从最好O(1) 最坏O(n) 平均O(n)</li><li>插入：数组若无序，插入新的元素时，可以将第K个位置元素移动到数组末尾，把心的元素，插入到第k个位置，此处复杂度为O(1)。作者举例说明<br><img src="http://upload-images.jianshu.io/upload_images/11332031-89b659d96d3d5df4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="插入"></li><li>删除：从最好O(1) 最坏O(n) 平均O(n)</li><li>多次删除集中在一起，提高删除效率<br>记录下已经被删除的数据，每次的删除操作并不是搬移数据，只是记录数据已经被删除，当数组没有更多的存储空间时，再触发一次真正的删除操作。即JVM标记清除垃圾回收算法。<h2 id="警惕数组的访问越界问题"><a href="#警惕数组的访问越界问题" class="headerlink" title="警惕数组的访问越界问题"></a>警惕数组的访问越界问题</h2>用C语言循环越界访问的例子说明访问越界的bug。此例在《C陷阱与缺陷》出现过，很惭愧，看过但是现在也只有一丢丢印象。翻了下书，替作者加上一句话：如果用来编译这段程序的编译器按照内存地址递减的方式给变量分配内存，那么内存中的i将会被置为0，则为死循环永远出不去。<h2 id="容器能否完全替代数组"><a href="#容器能否完全替代数组" class="headerlink" title="容器能否完全替代数组"></a>容器能否完全替代数组</h2>相比于数字，java中的ArrayList封装了数组的很多操作，并支持动态扩容。一旦超过村塾容量，扩容时比较耗内存，因为涉及到内存申请和数据搬移。<br>数组适合的场景：</li><li>Java ArrayList 的使用涉及装箱拆箱，有一定的性能损耗，如果特别管柱性能，可以考虑数组</li><li>若数据大小事先已知，并且涉及的数据操作非常简单，可以使用数组</li><li>表示多维数组时，数组往往更加直观。</li><li>业务开发容器即可，底层开发，如网络框架，性能优化。选择数组。<h2 id="解答开篇问题"><a href="#解答开篇问题" class="headerlink" title="解答开篇问题"></a>解答开篇问题</h2></li><li>从偏移角度理解a[0] 0为偏移量，如果从1计数，会多出K-1。增加cpu负担。为什么循环要写成for(int i = 0;i&lt;3;i++) 而不是for(int i = 0 ;i&lt;=2;i++)。第一个直接就可以算出3-0 = 3 有三个数据，而后者 2-0+1个数据，多出1个加法运算，很恼火。</li><li>也有一定的历史原因<h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2>大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有 GC ROOTS，将所有 GC ROOTS 可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。</li></ul><p>不足：1.效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效。2.空间问题。会产生不连续的内存空间碎片。</p><p>二维数组内存寻址：</p><p>对于 m * n 的数组，a [ i ][ j ] (i &lt; m,j &lt; n)的地址为：</p><p>address = base_address + ( i <em> n + j) </em> type_size</p><p>另外，对于数组访问越界造成无限循环，我理解是编译器的问题，对于不同的编译器，在内存分配时，会按照内存地址递增或递减的方式进行分配。老师的程序，如果是内存地址递减的方式，就会造成无限循环。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h1&gt;&lt;h2 id=&quot;数组如何实现随机访问&quot;&gt;&lt;a href=&quot;#数组如何实现随机访问&quot; class=&quot;headerlink&quot; title=&quot;数组如何实
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://ttongniu.github.io/NTTBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://ttongniu.github.io/NTTBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>复杂度分析--下篇</title>
    <link href="https://ttongniu.github.io/NTTBlog/2019/04/05/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8B/"/>
    <id>https://ttongniu.github.io/NTTBlog/2019/04/05/复杂度分析-下/</id>
    <published>2019-04-05T15:02:51.000Z</published>
    <updated>2019-04-05T15:03:56.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅析最好、最坏、平均、均摊时间复杂度"><a href="#浅析最好、最坏、平均、均摊时间复杂度" class="headerlink" title="浅析最好、最坏、平均、均摊时间复杂度"></a>浅析最好、最坏、平均、均摊时间复杂度</h1><h2 id="最好情况时间复杂度、"><a href="#最好情况时间复杂度、" class="headerlink" title="最好情况时间复杂度、"></a>最好情况时间复杂度、</h2><p>在最理想的情况下，执行这段代码的时间复杂度</p><h2 id="最坏情况时间复杂度、"><a href="#最坏情况时间复杂度、" class="headerlink" title="最坏情况时间复杂度、"></a>最坏情况时间复杂度、</h2><p>在最糟糕的情况下，执行这段代码的时间复杂度</p><h2 id="平均情况时间复杂度、"><a href="#平均情况时间复杂度、" class="headerlink" title="平均情况时间复杂度、"></a>平均情况时间复杂度、</h2><p>最好与最坏是在极端情况下发生的，平均情况复杂度引入了概率，所以也叫加权平均时间复杂度或者期望时间复杂度。<br>如出现n次情况，将出现n次中每次情况乘以每次情况出现的概率在相加，除以n，再去常量就可以得到平均时间复杂度。</p><h2 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h2><p>在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。</p><h3 id="举个荔枝："><a href="#举个荔枝：" class="headerlink" title="举个荔枝："></a>举个荔枝：</h3><p>今天你准备去老王家拜访下，可惜老王的爱人叫他去打个酱油，她告诉你说她限时n分钟🕒给他去买。那么你想着以他家到楼下小卖部来回最多一分钟，那么 “最好的情况”就是你只用等他一分钟。那么也有可能遇到突发情况，比如说电梯人多吖，路上摔了一胶，天知道他去干了什么，用了n分钟，没办法👐，主上有令，n分钟限时，那这就是“最坏的情况”。难点，平均时间复杂度 就是他有可能是第1.2.3…n，中的某个分钟回来，那平均就是1+2+3+…n/n，把 所有可能出现的情况的时间复杂度 相加除以 情况数 。均摊的话就是把花时间多的分给花时间少的，得到一个中间值，所以说这就会和平均混淆，个人觉得主要还是概念不同。假如n是10分钟，那么9分钟分4分钟到1分钟那，8分3给2…，那均摊下来就是5分钟.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;浅析最好、最坏、平均、均摊时间复杂度&quot;&gt;&lt;a href=&quot;#浅析最好、最坏、平均、均摊时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;浅析最好、最坏、平均、均摊时间复杂度&quot;&gt;&lt;/a&gt;浅析最好、最坏、平均、均摊时间复杂度&lt;/h1&gt;&lt;h2 id=&quot;最
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://ttongniu.github.io/NTTBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://ttongniu.github.io/NTTBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>复杂度分析--上篇</title>
    <link href="https://ttongniu.github.io/NTTBlog/2019/04/05/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8A%E7%AF%87/"/>
    <id>https://ttongniu.github.io/NTTBlog/2019/04/05/复杂度分析-上篇/</id>
    <published>2019-04-05T14:45:45.000Z</published>
    <updated>2019-04-05T14:47:28.473Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是复杂度分析？"><a href="#什么是复杂度分析？" class="headerlink" title="什么是复杂度分析？"></a>什么是复杂度分析？</h1><ul><li>数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。</li><li>因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。</li><li>分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称4.为复杂度。</li><li>复杂度描述的是算法执行时间（或占用如何分析、统计算法的执行效率和资源消耗空间）与数据规模的增长关系。<h1 id="为什么要进行复杂度分析？"><a href="#为什么要进行复杂度分析？" class="headerlink" title="为什么要进行复杂度分析？"></a>为什么要进行复杂度分析？</h1><ul><li>和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。</li><li>掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。<h1 id="如何进行复杂度分析？"><a href="#如何进行复杂度分析？" class="headerlink" title="如何进行复杂度分析？"></a>如何进行复杂度分析？</h1><h2 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h2></li><li>来源</li></ul></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/11332031-b57e131451acc9a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公式"><br> 算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。</p><ul><li>特点<br>以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。</li></ul><h2 id="时间复杂度分析分析法则"><a href="#时间复杂度分析分析法则" class="headerlink" title="时间复杂度分析分析法则"></a>时间复杂度分析分析法则</h2><ul><li>只关注循环执行次数最多的一段代码–单段代码看高频：比如循环。</li><li>加法法则：总复杂度等于量级最大的那段代码的复杂度–比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。</li><li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积–嵌套代码求乘积：比如递归、多重循环等</li><li>多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。<h2 id="几种常见时间复杂度实例分析"><a href="#几种常见时间复杂度实例分析" class="headerlink" title="几种常见时间复杂度实例分析"></a>几种常见时间复杂度实例分析</h2></li></ul><p>总结了一下，这些复杂度量级几乎涵盖了你今后可以接触的所有代码的复杂度量级。<br><img src="http://upload-images.jianshu.io/upload_images/11332031-2cbaec257f4bdd51.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="复杂度量级"><br>多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，<br>O(1)（常数阶）–一般情况下，只要算法中不存在循环语句、递归语句、即使有成千上万行的代码，其时间复杂度也是Ο(1)。、<br>O(logn)（对数阶）、<br>O(n)（线性阶）、<br>O(nlogn)（线性对数阶）–比如，归并排序、快速排序<br>O(n^2)（平方阶）、<br>O(n^3)（立方阶）<br>非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，<br>O(2^n)（指数阶）、<br>O(n!)（阶乘阶）<br>常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。<br><img src="http://upload-images.jianshu.io/upload_images/11332031-61ed22937a8c0200.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="复杂度"></p><h2 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><p>表示算法的执行时间与数据规模之间的增长关系。<br>常见的空间复杂度就是 O(1)、O(n)、O(n2 )。</p><h2 id="如何掌握好复杂度分析方法？"><a href="#如何掌握好复杂度分析方法？" class="headerlink" title="如何掌握好复杂度分析方法？"></a>如何掌握好复杂度分析方法？</h2><p>复杂度分析关键在于多练，所谓孰能生巧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是复杂度分析？&quot;&gt;&lt;a href=&quot;#什么是复杂度分析？&quot; class=&quot;headerlink&quot; title=&quot;什么是复杂度分析？&quot;&gt;&lt;/a&gt;什么是复杂度分析？&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。&lt;/l
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://ttongniu.github.io/NTTBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://ttongniu.github.io/NTTBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://ttongniu.github.io/NTTBlog/2019/03/24/hello-world/"/>
    <id>https://ttongniu.github.io/NTTBlog/2019/03/24/hello-world/</id>
    <published>2019-03-24T06:38:18.626Z</published>
    <updated>2019-03-31T07:00:43.477Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
