<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script src="/NTTBlog/lib/pace/pace.min.js?v=1.0.2"></script><link href="/NTTBlog/lib/pace/pace-theme-bounce.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/NTTBlog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/NTTBlog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/NTTBlog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/NTTBlog/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/NTTBlog/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/NTTBlog/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/NTTBlog/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="算法,"><link rel="alternate" href="/NTTBlog/atom.xml" title="求知若饥 ，虚心若愚" type="application/atom+xml"><meta name="description" content="一、线性排序算法介绍 线性排序算法包括桶排序、计数排序、基数排序。 线性排序算法的时间复杂度为O(n)。 此3种排序算法都不涉及元素之间的比较操作，是非基于比较的排序算法。 对排序数据的要求很苛刻，重点掌握此3种排序算法的适用场景。二、桶排序（Bucket sort）1.算法原理： 将要排序的### 数据分到几个有序的桶里，每个桶里的数据再单独进行快速排序。 桶内排完序之后，再把每个桶里的数据按照"><meta name="keywords" content="算法"><meta property="og:type" content="article"><meta property="og:title" content="排序--下篇"><meta property="og:url" content="https://ttongniu.github.io/NTTBlog/2019/04/06/排序-下篇/index.html"><meta property="og:site_name" content="求知若饥 ，虚心若愚"><meta property="og:description" content="一、线性排序算法介绍 线性排序算法包括桶排序、计数排序、基数排序。 线性排序算法的时间复杂度为O(n)。 此3种排序算法都不涉及元素之间的比较操作，是非基于比较的排序算法。 对排序数据的要求很苛刻，重点掌握此3种排序算法的适用场景。二、桶排序（Bucket sort）1.算法原理： 将要排序的### 数据分到几个有序的桶里，每个桶里的数据再单独进行快速排序。 桶内排完序之后，再把每个桶里的数据按照"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://upload-images.jianshu.io/upload_images/11332031-1b856abf6d33064b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><meta property="og:updated_time" content="2019-04-06T14:23:01.199Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="排序--下篇"><meta name="twitter:description" content="一、线性排序算法介绍 线性排序算法包括桶排序、计数排序、基数排序。 线性排序算法的时间复杂度为O(n)。 此3种排序算法都不涉及元素之间的比较操作，是非基于比较的排序算法。 对排序数据的要求很苛刻，重点掌握此3种排序算法的适用场景。二、桶排序（Bucket sort）1.算法原理： 将要排序的### 数据分到几个有序的桶里，每个桶里的数据再单独进行快速排序。 桶内排完序之后，再把每个桶里的数据按照"><meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/11332031-1b856abf6d33064b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/NTTBlog/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!0,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"bounceRightIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"bounceLeftIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://ttongniu.github.io/NTTBlog/2019/04/06/排序-下篇/"><title>排序--下篇 | 求知若饥 ，虚心若愚</title></head><script type="text/javascript" src="/js/src/clicklove.js"></script><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div> <a href="https://github.com/ttongniu/NTTBlog" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/NTTBlog/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">求知若饥 ，虚心若愚</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Stay hungry，Stay foolish</p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/NTTBlog/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-tags"><a href="/NTTBlog/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/NTTBlog/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/NTTBlog/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-sitemap"><a href="/NTTBlog/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i><br> 站点地图</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://ttongniu.github.io/NTTBlog/NTTBlog/2019/04/06/排序-下篇/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="ttongniu"><meta itemprop="description" content><meta itemprop="image" content="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=1109028906,1693670036&fm=173&app=25&f=JPEG?w=640&h=853&s=8D26ED174A606A8CD8C45D630300E061"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="求知若饥 ，虚心若愚"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">排序--下篇</h1><div class="post-meta"><i class="fa fa-thumb-tack"></i> <font color="7D26CD">置顶</font> <span class="post-meta-divider">|</span><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-06T22:14:42+08:00">2019-04-06</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/NTTBlog/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span></span> <span class="post-comments-count"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span><a href="/NTTBlog/2019/04/06/排序-下篇/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/NTTBlog/2019/04/06/排序-下篇/" itemprop="commentCount"></span></a></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">1.8k 字</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">6 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="一、线性排序算法介绍"><a href="#一、线性排序算法介绍" class="headerlink" title="一、线性排序算法介绍"></a>一、线性排序算法介绍</h2><ul><li>线性排序算法包括桶排序、计数排序、基数排序。</li><li>线性排序算法的时间复杂度为O(n)。</li><li>此3种排序算法都不涉及元素之间的比较操作，是非基于比较的排序算法。</li><li>对排序数据的要求很苛刻，重点掌握此3种排序算法的适用场景。<h2 id="二、桶排序（Bucket-sort）"><a href="#二、桶排序（Bucket-sort）" class="headerlink" title="二、桶排序（Bucket sort）"></a>二、桶排序（Bucket sort）</h2><h3 id="1-算法原理："><a href="#1-算法原理：" class="headerlink" title="1.算法原理："></a>1.算法原理：</h3></li><li>将要排序的### 数据分到几个有序的桶里，每个桶里的数据再单独进行快速排序。</li><li>桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。<br><img src="http://upload-images.jianshu.io/upload_images/11332031-1b856abf6d33064b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="桶排序"><h3 id="2-使用条件"><a href="#2-使用条件" class="headerlink" title="2.使用条件"></a>2.使用条件</h3></li><li>要排序的数据需要很容易就能划分成m个桶，并且桶与桶之间有着天然的大小顺序。</li><li>数据在各个桶之间分布是均匀的。<h3 id="3-适用场景"><a href="#3-适用场景" class="headerlink" title="3.适用场景"></a>3.适用场景</h3></li><li>桶排序比较适合用在外部排序中。</li><li>外部排序就是数据存储在外部磁盘且数据量大，但内存有限无法将整个数据全部加载到内存中。<h3 id="4-应用案例"><a href="#4-应用案例" class="headerlink" title="4.应用案例"></a>4.应用案例</h3></li><li>需求描述：<br>有10GB的订单数据，需按订单金额（假设金额都是正整数）进行排序<br>但内存有限，仅几百MB</li><li>解决思路：<br>扫描一遍文件，看订单金额所处数据范围，比如1元-10万元，那么就分100个桶。<br>第一个桶存储金额1-1000元之内的订单，第二个桶存1001-2000元之内的订单，依次类推。<br>每个桶对应一个文件，并按照金额范围的大小顺序编号命名（00，01，02，…，99）。<br>将100个小文件依次放入内存并用快排排序。<br>所有文件排好序后，只需按照文件编号从小到大依次读取每个小文件并写到大文件中即可。</li><li>注意点：若单个文件无法全部载入内存，则针对该文件继续按照前面的思路进行处理即可。<h2 id="三、计数排序（Counting-sort）"><a href="#三、计数排序（Counting-sort）" class="headerlink" title="三、计数排序（Counting sort）"></a>三、计数排序（Counting sort）</h2><h3 id="1-算法原理"><a href="#1-算法原理" class="headerlink" title="1.算法原理"></a>1.算法原理</h3></li><li>计数其实就是桶排序的一种特殊情况。</li><li>当要排序的n个数据所处范围并不大时，比如最大值为k，则分成k个桶</li><li>每个桶内的数据值都是相同的，就省掉了桶内排序的时间。<h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 计数排序，a 是数组，n 是数组大小。假设数组中存储的都是非负整数。</span><br><span class="line">public void countingSort(int[] a, int n) &#123;</span><br><span class="line">  if (n &lt;= 1) return;</span><br><span class="line"></span><br><span class="line">  // 查找数组中数据的范围</span><br><span class="line">  int max = a[0];</span><br><span class="line">  for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">    if (max &lt; a[i]) &#123;</span><br><span class="line">      max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int[] c = new int[max + 1]; // 申请一个计数数组 c，下标大小 [0,max]</span><br><span class="line">  for (int i = 0; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 计算每个元素的个数，放入 c 中</span><br><span class="line">  for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">    c[a[i]]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 依次累加</span><br><span class="line">  for (int i = 1; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = c[i-1] + c[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 临时数组 r，存储排序之后的结果</span><br><span class="line">  int[] r = new int[n];</span><br><span class="line">  // 计算排序的关键步骤，有点难理解</span><br><span class="line">  for (int i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">    int index = c[a[i]]-1;</span><br><span class="line">    r[index] = a[i];</span><br><span class="line">    c[a[i]]--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 将结果拷贝给 a 数组</span><br><span class="line">  for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">    a[i] = r[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>案例分析：<br>假设只有8个考生分数在0-5分之间，成绩存于数组A[8] = [2，5，3，0，2，3，0，3]。<br>使用大小为6的数组C[6]表示桶，下标对应分数，即0，1，2，3，4，5。<br>C[6]存储的是考生人数，只需遍历一边考生分数，就可以得到C[6] = [2，0，2，3，0，1]。<br>对C[6]数组顺序求和则C[6]=[2，2，4，7，7，8]，c[k]存储的是小于等于分数k的考生个数。<br>数组R[8] = [0，0，2，2，3，3，3，5]存储考生名次。那么如何得到R[8]的呢？<br>从后到前依次扫描数组A，比如扫描到3时，可以从数组C中取出下标为3的值7，也就是说，到目前为止，包括自己在内，分数小于等于3的考生有7个，也就是说3是数组R的第7个元素（也就是数组R中下标为6的位置）。当3放入数组R后，小于等于3的元素就剩下6个了，相应的C[3]要减1变成6。<br>以此类推，当扫描到第二个分数为3的考生时，就会把它放入数组R中第6个元素的位置（也就是下标为5的位置）。当扫描完数组A后，数组R内的数据就是按照分数从小到大排列的了。</p><h3 id="3-使用条件"><a href="#3-使用条件" class="headerlink" title="3.使用条件"></a>3.使用条件</h3><ul><li>只能用在数据范围不大的场景中，若数据范围k比要排序的数据n大很多，就不适合用计数排序；</li><li>计数排序只能给非负整数排序，其他类型需要在不改变相对大小情况下，转换为非负整数；</li><li>比如如果考试成绩精确到小数后一位，就需要将所有分数乘以10，转换为整数。<h2 id="四、基数排序（Radix-sort）"><a href="#四、基数排序（Radix-sort）" class="headerlink" title="四、基数排序（Radix sort）"></a>四、基数排序（Radix sort）</h2><h3 id="1-算法原理（以排序10万个手机号为例来说明）"><a href="#1-算法原理（以排序10万个手机号为例来说明）" class="headerlink" title="1.算法原理（以排序10万个手机号为例来说明）"></a>1.算法原理（以排序10万个手机号为例来说明）</h3></li><li>比较两个手机号码a，b的大小，如果在前面几位中a已经比b大了，那后面几位就不用看了。</li><li>借助稳定排序算法的思想，可以先按照最后一位来排序手机号码，然后再按照倒数第二位来重新排序，以此类推，最后按照第一个位重新排序。</li><li>经过11次排序后，手机号码就变为有序的了。</li><li>每次排序有序数据范围较小，可以使用桶排序或计数排序来完成。<h3 id="2-使用条件-1"><a href="#2-使用条件-1" class="headerlink" title="2.使用条件"></a>2.使用条件</h3></li><li>要求数据可以分割独立的“位”来比较；</li><li>位之间由递进关系，如果a数据的高位比b数据大，那么剩下的地位就不用比较了；</li><li>每一位的数据范围不能太大，要可以用线性排序，否则基数排序的时间复杂度无法做到O(n)。<h2 id="五、思考"><a href="#五、思考" class="headerlink" title="五、思考"></a>五、思考</h2></li><li>1.如何根据年龄给100万用户数据排序？<ul><li>答：利用桶排序。</li></ul></li><li>2.对D，a，F，B，c，A，z这几个字符串进行排序，要求将其中所有小写字母都排在大写字母前面，但是小写字母内部和大写字母内部不要求有序。比如<br>经过排序后为a，c，z，D，F，B，A，这个如何实现呢？如果字符串中处理大小写，还有数字，将数字放在最前面，又该如何解决呢？</li><li>答：用两个指针a、b：a指针从头开始往后遍历，遇到大写字母就停下，b从后往前遍历，遇到小写字母就停下，交换a、b指针对应的元素；重复如上过程，直到a、b指针相交。<br>对于小写字母放前面，数字放中间，大写字母放后面，可以先将数据分为小写字母和非小写字母两大类，进行如上交换后再在非小写字母区间内分为数字和大写字母做同样处理</li></ul></div><div><div><div style="text-align:center;color:#ccc;font-size:14px"> -------------本文结束<i class="fa fa-paw"></i> 感谢您的阅读-------------</div></div></div><footer class="post-footer"><div class="post-tags"><a href="/NTTBlog/tags/算法/" rel="tag"><i class="fa fa-tag"></i> 算法</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/NTTBlog/2019/04/06/排序-中篇/" rel="next" title="排序--中篇"><i class="fa fa-chevron-left"></i> 排序--中篇</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/NTTBlog/2019/04/06/排序优化/" rel="prev" title="排序优化">排序优化<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=1109028906,1693670036&fm=173&app=25&f=JPEG?w=640&h=853&s=8D26ED174A606A8CD8C45D630300E061" alt="ttongniu"><p class="site-author-name" itemprop="name">ttongniu</p><p class="site-description motion-element" itemprop="description">Just do your best</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=409654891&auto=1&height=32"></iframe></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/NTTBlog/archives/"><span class="site-state-item-count">18</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/NTTBlog/categories/index.html"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/NTTBlog/tags/index.html"><span class="site-state-item-count">6</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/NTTBlog/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/ttongniu" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="https://www.jianshu.com/u/87daaebec1c9" target="_blank" title="简书"><i class="fa fa-fw fa-heartbeat"></i> 简书</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 推荐阅读</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://colobu.com/categories/Java/" title="鸟窝-JAVA" target="_blank">鸟窝-JAVA</a></li><li class="links-of-blogroll-item"> <a href="https://www.bysocket.com/archives/2100/java-%E6%A0%B8%E5%BF%83" title="泥瓦匠-JAVA" target="_blank">泥瓦匠-JAVA</a></li><li class="links-of-blogroll-item"> <a href="http://www.importnew.com/" title="ImportNew" target="_blank">ImportNew</a></li><li class="links-of-blogroll-item"> <a href="http://ifeve.com/" title="并发编程网" target="_blank">并发编程网</a></li><li class="links-of-blogroll-item"> <a href="https://www.jianshu.com/u/90ab66c248e6" title="占小狼" target="_blank">占小狼</a></li></ul></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、线性排序算法介绍"><span class="nav-number">1.</span> <span class="nav-text">一、线性排序算法介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、桶排序（Bucket-sort）"><span class="nav-number">2.</span> <span class="nav-text">二、桶排序（Bucket sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-算法原理："><span class="nav-number">2.1.</span> <span class="nav-text">1.算法原理：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-使用条件"><span class="nav-number">2.2.</span> <span class="nav-text">2.使用条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-适用场景"><span class="nav-number">2.3.</span> <span class="nav-text">3.适用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-应用案例"><span class="nav-number">2.4.</span> <span class="nav-text">4.应用案例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、计数排序（Counting-sort）"><span class="nav-number">3.</span> <span class="nav-text">三、计数排序（Counting sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-算法原理"><span class="nav-number">3.1.</span> <span class="nav-text">1.算法原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-代码实现"><span class="nav-number">3.2.</span> <span class="nav-text">2.代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-使用条件"><span class="nav-number">3.3.</span> <span class="nav-text">3.使用条件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、基数排序（Radix-sort）"><span class="nav-number">4.</span> <span class="nav-text">四、基数排序（Radix sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-算法原理（以排序10万个手机号为例来说明）"><span class="nav-number">4.1.</span> <span class="nav-text">1.算法原理（以排序10万个手机号为例来说明）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-使用条件-1"><span class="nav-number">4.2.</span> <span class="nav-text">2.使用条件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、思考"><span class="nav-number">5.</span> <span class="nav-text">五、思考</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">ttongniu</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/NTTBlog/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/NTTBlog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/NTTBlog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/NTTBlog/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/NTTBlog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/NTTBlog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/NTTBlog/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/NTTBlog/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/NTTBlog/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/NTTBlog/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/NTTBlog/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/NTTBlog/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/NTTBlog/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/NTTBlog/js/src/bootstrap.js?v=5.1.4"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'OqC1jORLurGDXueXCJmvgU0T-gzGzoHsz',
        appKey: 'BhmSpHx35VkHWFCMztSV73Cy',
        placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script><script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/NTTBlog/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><script src="/NTTBlog/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",model:{jsonPath:"/NTTBlog/live2dw/assets/hijiki.model.json"},display:{position:"right",width:100,height:200},mobile:{show:!1},log:!1,tagMode:!1})</script></body></html>