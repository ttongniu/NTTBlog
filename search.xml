<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[集群高可用、哨兵、持久化、LRU]]></title>
    <url>%2FNTTBlog%2F2020%2F04%2F14%2F%E9%9B%86%E7%BE%A4%E9%AB%98%E5%8F%AF%E7%94%A8%E3%80%81%E5%93%A8%E5%85%B5%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96%E3%80%81LRU%2F</url>
    <content type="text"><![CDATA[Redis 为什么那么快 （10万+/qps） 完全基于内存，绝大多数请求是纯粹的内存操作。 数据结构简单 对数据操作也简单 Redis中的数据结构是专门进行设计的 采取单线程 避免了上下文切换 、竞争条件 锁的问题等 使用IO复用模型 非阻塞 （单线程 多核服务器 我们可以开多个Redis实例） （单机有瓶颈 我们就玩集群 Redis cluster 并且是主从同步 读写分离， Redis cluster 可以支撑N个master node 每个masternode 可以挂载多个slave node） Redis持久化哨兵主从同步###内存淘汰策略]]></content>
  </entry>
  <entry>
    <title><![CDATA[缓存雪崩、穿透、击穿]]></title>
    <url>%2FNTTBlog%2F2020%2F04%2F14%2F%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%2F</url>
    <content type="text"><![CDATA[缓存雪崩​ 热点数据都会去做缓存，一般缓存都是定时任务去刷新，或者再查不到的时候去更新。我们在缓存数据时会加上过期时间。 当同一时间大面积缓存过期，一瞬间Redis跟没有一样。大量请求直接打到数据库中。 数据库必然扛不住挂了。导致服务瘫痪。 在批量往Redis存数据时，把每个key的失效时间都加上个随机数就好了，保证数据不会在同一时间大面积失效。 保证Redis集群的高可用 主从+哨兵+ 缓存穿透​ 不断请求 缓存与数据库中都不存在的数据。 查数据库时返回null 时也缓存到Redis中 （过期时间设置短一点）。 提供接口时 保持不信任原则 做好参数的校验 非法参数直接返回。 使用Redis的高级用法 – 布隆过滤器 – 原理： bigMap 数据结构+ hash算法 。 缓存击穿​ 热点数据失效，导致大量请求直接打到数据库。 热点数据设置永不失效。 采用分布式锁 查询数据库 更新缓存]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList 源码-1.8]]></title>
    <url>%2FNTTBlog%2F2020%2F04%2F13%2FArrayList-%E6%BA%90%E7%A0%81-1-8%2F</url>
    <content type="text"><![CDATA[###无参构造器 123456/** * 构造一个空列表的初始容量10。; */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; ###有参构造器 12345678910111213141516/** * 构造一个与指定初始容量的空列表。; * * @param initialCapacity 列表的初始容量; * @throws IllegalArgumentException 如果指定的初始容量是负的; */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125; &#125; add 添加方法1234567891011/** * 将指定的元素添加到列表尾部; * * @param e 追加到这个列表的元素 * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */ public boolean add(E e) &#123; ensureCapacityInternal(size + 1); //Increments modCount!! elementData[size++] = e; return true; &#125; 123456789101112131415161718private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity; &#125; private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; 123456789101112131415161718192021222324/** * 扩容的能力,以确保它可以容纳至少最低容量参数指定的元素的个数。; * * @param minCapacity 所需的最小容量; */ private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[jvm调优]]></title>
    <url>%2FNTTBlog%2F2020%2F04%2F12%2Fjvm%E8%B0%83%E4%BC%98%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[手撕LRU]]></title>
    <url>%2FNTTBlog%2F2020%2F04%2F12%2F%E6%89%8B%E6%92%95LRU%2F</url>
    <content type="text"><![CDATA[手撕LUR代码思路总结 hashMap+ 双向列表 在双向链表实现中，这里使用一个伪头部和伪尾部标记界限，这样在更新的时候就不需要检查是否是null节点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586class LRUCache &#123; //双向链表 class DlinkedNode&#123; int key; int value; DLinkNode prev; DLinkNode next; &#125; // 头插入 private void addNode(DLinkedNode node)&#123; node.prev = head; node.next = head.next; head.next.prev =node; head.next = node; &#125; //删除节点 private void removeNode(DLinkedNode node)&#123; DLinkedNode prev = node.prev; DLinkedNode next = node.next; prev.next = next; next.prev = prev; &#125; //移动到头部 private void MoveToHead(DLinkedNode node)&#123; removeNode(node); addNode(node); &#125; //移除尾部节点 private DLinkedNode popTail()&#123; DLinkedNode res = tail.prev; removeNode(node); return res; &#125; private Map&lt;Integer,DLinkedNode&gt; cache = new HashMap&lt;Integer,DLinkedNode&gt;(); private int size; private int capacity; private DLinkedNode head,tail; public LRUCache(int capacity) &#123; this.size =0; this.capacity = capacity; head = new DLinkedNode(); tail = new DLinkedNode(); head.next = tail; tail.prev=head; &#125; public int get(int key) &#123; DLinkedNode node = cache.get(key); if(node == null)&#123; return -1; &#125; moveToHead(node); return node.value; &#125; public void put(int key, int value) &#123; //首先查有无 //有的 变更value值 移到头部 if(node!=null)&#123; node.value = value; moveToHead(node); &#125;else&#123; DLinkedNode newNode = new DLinkedNode(); newNode.key = key; newNode.value = value; cache.put(key,newNode); addNode(newNode); ++size; if(size&gt;capacity)&#123; DLinkedNode tail = popTail(); chche.remove(tail.key); --size; &#125; &#125; &#125;&#125;/** * LRUCache 对象会以如下语句构造和调用: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */ 复杂度分析 时间复杂度：对于 put 和 get 都是 O(1)O(1)。空间复杂度：O(capacity)O(capacity)，因为哈希表和双向链表最多存储 capacity + 1 个元素。]]></content>
  </entry>
  <entry>
    <title><![CDATA[单例模式学习]]></title>
    <url>%2FNTTBlog%2F2019%2F06%2F09%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Ⅰ 懒汉式-线程不安全1234567891011121314151617181920212223242526272829/** * @ClassName Singleton01 * @Description Ⅰ 懒汉式-线程不安全 * * 以下实现中，私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。 * * 这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 if (uniqueInstance == null) ，并且此时 uniqueInstance 为 null，那么会有多个线程执行 uniqueInstance = new Singleton(); 语句，这将导致实例化多次 uniqueInstance。 * * * @Author niu * @Date 2019-06-02 18:14 * @Version V1.0 **/public class Singleton01 &#123; //私有构造函数 private Singleton01 ()&#123; &#125; //私有静态变量 private static Singleton01 UniqueInstance; //公有静态函数 public static Singleton01 getUniqueInstance()&#123; if(UniqueInstance == null)&#123; UniqueInstance = new Singleton01(); &#125; return UniqueInstance; &#125;&#125; Ⅱ 饿汉式-线程安全12345678910111213141516171819202122232425262728293031package com.java.ntt.designPatterns.Singleton;/** * @ClassName Singleton02 * @Description Ⅱ 饿汉式-线程安全 * *只需要对 getUniqueInstance() 方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了实例化多次 uniqueInstance。 * * 但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 uniqueInstance 已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。 * * @Author niu * @Date 2019-06-02 18:22 * @Version V1.0 **/public class Singleton02 &#123; //私有构造器 private Singleton02()&#123; &#125; //私有静态变量 private static Singleton02 uniqueInstance=new Singleton02(); //公有静态函数 public static synchronized Singleton02 getUniqueInstance()&#123; if(uniqueInstance==null) &#123; uniqueInstance = new Singleton02(); &#125; return uniqueInstance; &#125;&#125; Ⅳ 双重校验锁-线程安全123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.java.ntt.designPatterns.Singleton;/** * @ClassName Singleton03 * @Description Ⅳ 双重校验锁-线程安全 * *uniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。 * * 双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。 * 考虑下面的实现，也就是只使用了一个 if 语句。在 uniqueInstance == null 的情况下，如果两个线程都执行了 if 语句，那么两个线程都会进入 if 语句块内。虽然在 if 语句块内有加锁操作，但是两个线程都会执行 uniqueInstance = new Singleton(); 这条语句，只是先后的问题，那么就会进行两次实例化。因此必须使用双重校验锁， * * * uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行： * * 1.为 uniqueInstance 分配内存空间 * 2.初始化 uniqueInstance * 3.将 uniqueInstance 指向分配的内存地址 * 但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。 * * 使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。 * @Author niu * @Date 2019-06-02 18:27 * @Version V1.0 **/public class Singleton03 &#123; private Singleton03()&#123; &#125; private static volatile Singleton03 uniqueInstance = new Singleton03(); public static Singleton03 getUniqueInstance()&#123; if(uniqueInstance == null)&#123; synchronized (Singleton03.class)&#123; if(uniqueInstance == null)&#123; uniqueInstance = new Singleton03(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125; Ⅴ 静态内部类实现12345678910111213141516171819202122232425262728package com.java.ntt.designPatterns.Singleton;/** * @ClassName Singleton04 * @Description Ⅴ 静态内部类实现 * *当 Singleton 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 getUniqueInstance() 方法从而触发 SingletonHolder.INSTANCE 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。 * * 这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。 * * @Author niu * @Date 2019-06-02 18:34 * @Version V1.0 **/public class Singleton04 &#123; //私有化构造器 private Singleton04()&#123; &#125; private static class SingletonHolder&#123; private static final Singleton04 INSTANCE = new Singleton04(); &#125; public static Singleton04 getUniqueInstance()&#123; return SingletonHolder.INSTANCE; &#125;&#125; Ⅵ 枚举实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.java.ntt.designPatterns.Singleton;/** * @ClassName Singleton05 * @Description Ⅵ 枚举实现 * 该实现在多次序列化再进行反序列化之后，不会得到多个实例。而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法。 * 该实现可以防止反射攻击。在其它实现中，通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。 * @Author niu * @Date 2019-06-02 18:38 * @Version V1.0 **/public enum Singleton05 &#123; INSTANCE; private String objName; public String getObjName() &#123; return objName; &#125; public void setObjName(String objName) &#123; this.objName = objName; &#125; public static void main(String[] args) &#123; // 单例测试 Singleton05 firstSingleton = Singleton05.INSTANCE; firstSingleton.setObjName(&quot;firstName&quot;); System.out.println(firstSingleton.getObjName()); Singleton05 secondSingleton = Singleton05.INSTANCE; secondSingleton.setObjName(&quot;secondName&quot;); System.out.println(firstSingleton.getObjName()); System.out.println(secondSingleton.getObjName()); // 反射获取实例测试 try &#123; Singleton05[] enumConstants = Singleton05.class.getEnumConstants(); for (Singleton05 enumConstant : enumConstants) &#123; System.out.println(enumConstant.getObjName()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 学习参考： 传送门]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM--CMS与G1垃圾收集器]]></title>
    <url>%2FNTTBlog%2F2019%2F04%2F07%2FJVM-CMS%E4%B8%8EG1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[CMS （Concurent mark sweep）并发标记清除 步骤： 初始标记 并发标记 重新标记 并发清除 特点：并发收集、低停顿 问题CPU敏感、浮动垃圾、碎片 G1（Garbage first）垃圾优先 不同于其他的分代回收算法、G1将堆空间划分成了互相独立的区块。每块区域既有可能属于O区、也有可能是Y区，且每类区域空间可以是不连续的（对比CMS的O区和Y区都必须是连续的）。这种将O区划分成多块的理念源于：当并发后台线程寻找可回收的对象时、有些区块包含可回收的对象要比其他区块多很多。虽然在清理这些区块时G1仍然需要暂停应用线程、但可以用相对较少的时间优先回收包含垃圾最多区块。这也是为什么G1命名为Garbage First的原因：第一时间处理垃圾最多的区块。 G1相比CMS G1在压缩空间方面有优势 G1通过将内存空间分成区域（Region）的方式避免内存碎片问题 Eden, Survivor, Old区不再固定、在内存使用效率上来说更灵活 G1可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间避免应用雪崩现象 G1在回收内存后会马上同时做合并空闲内存的工作、而CMS默认是在STW（stop the world）的时候做 G1会在Young GC中使用、而CMS只能在O区使用 G1适合的场景 服务端多核CPU、JVM内存占用较大的应用（至少大于4G） 应用在运行过程中会产生大量内存碎片、需要经常压缩空间 想要更可控、可预期的GC停顿周期；防止高并发下应用雪崩现象 G1的四种回收操作方式 YGC（不同于CMS） 并发阶段 混合模式 full GC （一般是G1出现问题时发生）就目前而言、CMS还是默认首选的GC策略 图中每个小区块都代表G1的一个区域（Region），区块里面的字母代表不同的分代内存空间类型（如[E]Eden,[O]Old,[S]Survivor）空白的区块不属于任何一个分区；G1可以在需要的时候任意指定这个区域属于Eden或是O区之类的。G1 YoungGC在Eden充满时触发，在回收之后所有之前属于Eden的区块全变成空白。然后至少有一个区块是属于S区的（如图半满的那个区域），同时可能有一些数据移到了O区。 Young区发生了变化、这意味着在G1并发阶段内至少发生了一次YGC（这点和CMS就有区别），Eden在标记之前已经被完全清空，因为在并发阶段应用线程同时在工作、所以可以看到Eden又有新的占用 一些区域被X标记，这些区域属于O区，此时仍然有数据存放、不同之处在G1已标记出这些区域包含的垃圾最多、也就是回收收益最高的区域 在并发阶段完成之后实际上O区的容量变得更大了（O+X的方块）。这时因为这个过程中发生了YGC有新的对象进入所致。此外，这个阶段在O区没有回收任何对象：它的作用主要是标记出垃圾最多的区块出来。对象实际上是在后面的阶段真正开始被回收. 像普通的YGC那样、G1完全清空掉Eden同时调整survivor区。另外，两个标记也被回收了，他们有个共同的特点是包含最多可回收的对象，因此这两个区域绝对部分空间都被释放了。这两个区域任何存活的对象都被移到了其他区域（和YGC存活对象晋升到O区类似）。这就是为什么G1的堆比CMS内存碎片要少很多的原因–移动这些对象的同时也就是在压缩对内存。 混合GC阶段会有survivor区的对象晋升到O区；另外，每次混合GC只是清理一部分的O区内存，整个GC会一直持续到几乎所有的标记区域垃圾对象都被回收，这个阶段完了之后G1会重新回到正常的YGC阶段。周期性的，当O区内存占用达到一定数量之后G1又会开启一次新的并行GC阶段.]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>垃圾收集器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM的内存管理]]></title>
    <url>%2FNTTBlog%2F2019%2F04%2F07%2FJVM%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[内存管理=内存分配+内存回收内存分配 JMM指Java内存管理线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存，又称作TLAB线程本地缓冲区，中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。 虚拟机栈特点如上图。局部变量表存放了各种基本数据类型，对象引用类型，（“对象引用”可能是一个对象起始地址的引用指针，也可能是一个指向代表对象的句柄，不同的JVM实现不同），和return Address类型StackOverflow ： 栈深度超出允许范围OutOfMemory： 当虚拟机栈在动态扩展时，无法申请到足够的内存则抛出 堆 线程共享 存放所有的对象实例和数组 可拓展-xmx -xms控制大小 OutOfMemoryError JVM规范中规定的是：所有对象实例及数组都要在堆上分配，但随着编译器发展，也出现了栈上分配等优化技术 没有在堆上完成对象的内存分配并且也无法扩展堆大小时，将抛出OutOfMemoryError 方法区 线程共享 存放所有已被加载的（类信息、常量、静态变量、JIT编译后的代码） Hotspot可以设置大小 OutOfMemoryError又称非堆，在Hotspot上，方法区的回收和堆的回收是绑定在一起的，任何一方触发full gc都会另一方也进行full gc运行时常量池 运行时常量池是方法区的一部分，所以也是全局共享的。 其作用是存储 Java 类文件常量池中的符号信息。 class 文件中存在常量池(非运行时常量池)，其在编译阶段就已经确定；JVM 规范对 class 文件结构有着严格的规范，必须符合此规范的 class 文件才会被 JVM 认可和装载。 运行时常量池 中保存着一些 class 文件中描述的符号引用，同时还会将这些符号引用所翻译出来的直接引用存储在 运行时常量池 中。 运行时常量池相对于 class 常量池一大特征就是其具有动态性，Java 规范并不要求常量只能在运行时才产生，也就是说运行时常量池中的内容并不全部来自 class 常量池，class 常量池并非运行时常量池的唯一数据输入口；在运行时可以通过代码生成常量并将其放入运行时常量池中。 同方法区一样，当运行时常量池无法申请到新的内存时，将抛出 OutOfMemoryError 异常。 ##内存溢出 堆溢出不断往数组中添加实例 栈溢出无限递归的方法调用–StackOverflow不断创建线程 — OOM 方法区与运行时常量溢出无尽的String.intern() — before jdk1.6通过cglib 字节码增强，不断创建新类 内存回收垃圾回收 — 如何判断对象已死 引用计数器 可达性分析2.1. 栈帧中引用的对象2.2. 方法区中静态属性引用的对象2.3. 方法区中常量引用的对象2.4. JNI引用的对象引用计数很难解决循环引用问题可达性分析通过从GC-Root，可能有多个，出发进行搜索，凡是没有在任何路径上的对象，就可以回收了 回收算法 标记-清除1.1. Stop The World1.2. 会产生大量碎片 复制 标记-整理3.1. 无需额外空间 分代收集4.1. 针对各年代的特点，采用不同算法。 标记就是通过可达性分析算法，为所有有引用的对象都打上标记，在标记和清除阶段，都需要将整个程序暂停，也就是stop-the-world。复制算法，如果不想浪费50%的空间，就必须有额外空间做担保，例如老年代给新生代担保，那么由于没有再额外的空间给老年代担保了，所以老年代就不能采用复制算法。标记-整理，又称作标记压缩，适合于老年代。 垃圾收集器Serial、ParNew、Parallel Scavenge、Serial Old、Parallel OldCMS 、G1CMS是知道Java7为止默认的server模式的垃圾收集器G1在Java7引入，在Java8成为推荐]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM的内存模型]]></title>
    <url>%2FNTTBlog%2F2019%2F04%2F07%2FJVM%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[内存模型 堆 虚拟机栈 本地方法栈 PC寄存器/程序计数器 方法区 直接内存内存模型，是由Java虚拟机规范制定的，Java规范分为语言规范和虚拟机规范。蓝色框， 堆和方法区 - 所有线程共享。绿色 ， 线程隔离的数据区。程序计数器是唯一没有定义OutOfMemoryError的内存区域。运行时常量池从Java7开始，已经将字符串常量池从PermGen移到了堆上。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序优化]]></title>
    <url>%2FNTTBlog%2F2019%2F04%2F06%2F%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[一、如何选择最优化的排序算法 为什选择快速排序？ 线性排序时间复杂度很低但使用场景特殊，如果要写一个通用排序函数，不能选择线性排序。 为了兼顾任意规模数据的排序，一般会首选时间复杂度为O(nlogn)的排序算法来实现排序函数。 同为O(nlogn)的快排和归并排序相比，归并排序不是原地排序算法，所以最优的选择是快排。二、如何优化快速排序？导致快排时间复杂度降为O(n)的原因是分区点选择不合理，最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。如何优化分区点的选择？有2种常用方法，如下：1.三数取中法 从区间的首、中、尾分别取一个数，然后比较大小，取中间值作为分区点。 如果要排序的数组比较大，那“三数取中”可能就不够用了，可能要“5数取中”或者“10数取中”。2.随机法：每次从要排序的区间中，随机选择一个元素作为分区点。3.警惕快排的递归发生堆栈溢出，有2中解决方法，如下： 限制递归深度，一旦递归超过了设置的阈值就停止递归。 在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈过程，这样就没有系统栈大小的限制。三、通用排序函数实现技巧 数据量不大时，可以采取用时间换空间的思路 数据量大时，优化快排分区点的选择 防止堆栈溢出，可以选择在堆上手动模拟调用栈解决 在排序区间中，当元素个数小于某个常数是，可以考虑使用O(n^2)级别的插入排序 用哨兵简化代码，每次排序都减少一次判断，尽可能把性能优化到极致四、思考1.Java中的排序函数都是用什么排序算法实现的？有有哪些技巧？ 答：查看了下Arrays.sort的源码，主要采用TimSort算法, 大致思路是这样的： 元素个数 &lt; 32, 采用二分查找插入排序(Binary Sort) 元素个数 &gt;= 32, 采用归并排序，归并的核心是分区(Run) 找连续升或降的序列作为分区，分区最终被调整为升序后压入栈 如果分区长度太小，通过二分插入排序扩充分区长度到分区最小阙值 每次压入栈，都要检查栈内已存在的分区是否满足合并条件，满足则进行合并 最终栈内的分区被全部合并，得到一个排序好的数组Timsort的合并算法非常巧妙： 找出左分区最后一个元素(最大)及在右分区的位置 找出右分区第一个元素(最小)及在左分区的位置 仅对这两个位置之间的元素进行合并，之外的元素本身就是有序的]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序--下篇]]></title>
    <url>%2FNTTBlog%2F2019%2F04%2F06%2F%E6%8E%92%E5%BA%8F-%E4%B8%8B%E7%AF%87%2F</url>
    <content type="text"><![CDATA[一、线性排序算法介绍 线性排序算法包括桶排序、计数排序、基数排序。 线性排序算法的时间复杂度为O(n)。 此3种排序算法都不涉及元素之间的比较操作，是非基于比较的排序算法。 对排序数据的要求很苛刻，重点掌握此3种排序算法的适用场景。二、桶排序（Bucket sort）1.算法原理： 将要排序的### 数据分到几个有序的桶里，每个桶里的数据再单独进行快速排序。 桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。2.使用条件 要排序的数据需要很容易就能划分成m个桶，并且桶与桶之间有着天然的大小顺序。 数据在各个桶之间分布是均匀的。3.适用场景 桶排序比较适合用在外部排序中。 外部排序就是数据存储在外部磁盘且数据量大，但内存有限无法将整个数据全部加载到内存中。4.应用案例 需求描述：有10GB的订单数据，需按订单金额（假设金额都是正整数）进行排序但内存有限，仅几百MB 解决思路：扫描一遍文件，看订单金额所处数据范围，比如1元-10万元，那么就分100个桶。第一个桶存储金额1-1000元之内的订单，第二个桶存1001-2000元之内的订单，依次类推。每个桶对应一个文件，并按照金额范围的大小顺序编号命名（00，01，02，…，99）。将100个小文件依次放入内存并用快排排序。所有文件排好序后，只需按照文件编号从小到大依次读取每个小文件并写到大文件中即可。 注意点：若单个文件无法全部载入内存，则针对该文件继续按照前面的思路进行处理即可。三、计数排序（Counting sort）1.算法原理 计数其实就是桶排序的一种特殊情况。 当要排序的n个数据所处范围并不大时，比如最大值为k，则分成k个桶 每个桶内的数据值都是相同的，就省掉了桶内排序的时间。2.代码实现1234567891011121314151617181920212223242526272829303132333435363738394041// 计数排序，a 是数组，n 是数组大小。假设数组中存储的都是非负整数。public void countingSort(int[] a, int n) &#123; if (n &lt;= 1) return; // 查找数组中数据的范围 int max = a[0]; for (int i = 1; i &lt; n; ++i) &#123; if (max &lt; a[i]) &#123; max = a[i]; &#125; &#125; int[] c = new int[max + 1]; // 申请一个计数数组 c，下标大小 [0,max] for (int i = 0; i &lt;= max; ++i) &#123; c[i] = 0; &#125; // 计算每个元素的个数，放入 c 中 for (int i = 0; i &lt; n; ++i) &#123; c[a[i]]++; &#125; // 依次累加 for (int i = 1; i &lt;= max; ++i) &#123; c[i] = c[i-1] + c[i]; &#125; // 临时数组 r，存储排序之后的结果 int[] r = new int[n]; // 计算排序的关键步骤，有点难理解 for (int i = n - 1; i &gt;= 0; --i) &#123; int index = c[a[i]]-1; r[index] = a[i]; c[a[i]]--; &#125; // 将结果拷贝给 a 数组 for (int i = 0; i &lt; n; ++i) &#123; a[i] = r[i]; &#125;&#125; 案例分析：假设只有8个考生分数在0-5分之间，成绩存于数组A[8] = [2，5，3，0，2，3，0，3]。使用大小为6的数组C[6]表示桶，下标对应分数，即0，1，2，3，4，5。C[6]存储的是考生人数，只需遍历一边考生分数，就可以得到C[6] = [2，0，2，3，0，1]。对C[6]数组顺序求和则C[6]=[2，2，4，7，7，8]，c[k]存储的是小于等于分数k的考生个数。数组R[8] = [0，0，2，2，3，3，3，5]存储考生名次。那么如何得到R[8]的呢？从后到前依次扫描数组A，比如扫描到3时，可以从数组C中取出下标为3的值7，也就是说，到目前为止，包括自己在内，分数小于等于3的考生有7个，也就是说3是数组R的第7个元素（也就是数组R中下标为6的位置）。当3放入数组R后，小于等于3的元素就剩下6个了，相应的C[3]要减1变成6。以此类推，当扫描到第二个分数为3的考生时，就会把它放入数组R中第6个元素的位置（也就是下标为5的位置）。当扫描完数组A后，数组R内的数据就是按照分数从小到大排列的了。 3.使用条件 只能用在数据范围不大的场景中，若数据范围k比要排序的数据n大很多，就不适合用计数排序； 计数排序只能给非负整数排序，其他类型需要在不改变相对大小情况下，转换为非负整数； 比如如果考试成绩精确到小数后一位，就需要将所有分数乘以10，转换为整数。四、基数排序（Radix sort）1.算法原理（以排序10万个手机号为例来说明） 比较两个手机号码a，b的大小，如果在前面几位中a已经比b大了，那后面几位就不用看了。 借助稳定排序算法的思想，可以先按照最后一位来排序手机号码，然后再按照倒数第二位来重新排序，以此类推，最后按照第一个位重新排序。 经过11次排序后，手机号码就变为有序的了。 每次排序有序数据范围较小，可以使用桶排序或计数排序来完成。2.使用条件 要求数据可以分割独立的“位”来比较； 位之间由递进关系，如果a数据的高位比b数据大，那么剩下的地位就不用比较了； 每一位的数据范围不能太大，要可以用线性排序，否则基数排序的时间复杂度无法做到O(n)。五、思考 1.如何根据年龄给100万用户数据排序？ 答：利用桶排序。 2.对D，a，F，B，c，A，z这几个字符串进行排序，要求将其中所有小写字母都排在大写字母前面，但是小写字母内部和大写字母内部不要求有序。比如经过排序后为a，c，z，D，F，B，A，这个如何实现呢？如果字符串中处理大小写，还有数字，将数字放在最前面，又该如何解决呢？ 答：用两个指针a、b：a指针从头开始往后遍历，遇到大写字母就停下，b从后往前遍历，遇到小写字母就停下，交换a、b指针对应的元素；重复如上过程，直到a、b指针相交。对于小写字母放前面，数字放中间，大写字母放后面，可以先将数据分为小写字母和非小写字母两大类，进行如上交换后再在非小写字母区间内分为数字和大写字母做同样处理]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序--中篇]]></title>
    <url>%2FNTTBlog%2F2019%2F04%2F06%2F%E6%8E%92%E5%BA%8F-%E4%B8%AD%E7%AF%87%2F</url>
    <content type="text"><![CDATA[快速排序算法原理快排的思想是这样的：如果要排序数组中下标从p到r之间的一组数据，我们选择p到r之间的任意一个数据作为pivot（分区点）。然后遍历p到r之间的数据，将小于pivot的放到左边，将大于pivot的放到右边，将povit放到中间。经过这一步之后，数组p到r之间的数据就分成了3部分，前面p到q-1之间都是小于povit的，中间是povit，后面的q+1到r之间是大于povit的。根据分治、递归的处理思想，我们可以用递归排序下标从p到q-1之间的数据和下标从q+1到r之间的数据，直到区间缩小为1，就说明所有的数据都有序了。 递推公式：quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r) 终止条件：p &gt;= r性能分析算法稳定性：因为分区过程中涉及交换操作，如果数组中有两个8，其中一个是pivot，经过分区处理后，后面的8就有可能放到了另一个8的前面，先后顺序就颠倒了，所以快速排序是不稳定的排序算法。比如数组[1,2,3,9,8,11,8]，取后面的8作为pivot，那么分区后就会将后面的8与9进行交换。时间复杂度：最好、最坏、平均情况快排也是用递归实现的，所以时间复杂度也可以用递推公式表示。如果每次分区操作都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并的相同。T(1) = C； n=1 时，只需要常量级的执行时间，所以表示为 C。T(n) = 2*T(n/2) + n； n&gt;1所以，快排的时间复杂度也是O(nlogn)。如果数组中的元素原来已经有序了，比如1，3，5，6，8，若每次选择最后一个元素作为pivot，那每次分区得到的两个区间都是不均等的，需要进行大约n次的分区，才能完成整个快排过程，而每次分区我们平均要扫描大约n/2个元素，这种情况下，快排的时间复杂度就是O(n^2)。前面两种情况，一个是分区及其均衡，一个是分区极不均衡，它们分别对应了快排的最好情况时间复杂度和最坏情况时间复杂度。那快排的平均时间复杂度是多少呢？T(n)大部分情况下是O(nlogn)，只有在极端情况下才是退化到O(n^2)，而且我们也有很多方法将这个概率降低。空间复杂度：快排是一种原地排序算法，空间复杂度是O(1)代码实现快速排序 –利用的哨兵1234567891011121314151617181920private static void quickSort(int[] a, int head, int tail) &#123;int low = head;int high = tail;int pivot = a[low];if (low &lt; high) &#123;while (low&lt;high) &#123;while (low &lt; high &amp;&amp; pivot &lt;= a[high]) high--;a[low] = a[high];while (low &lt; high &amp;&amp; pivot &gt;= a[low]) low++;a[high]=a[low];&#125;a[low] = pivot;if(low&gt;head+1) quickSort(a,head,low-1);if(high&lt;tail-1) quickSort(a,high+1,tail);&#125;&#125; // 归并排序算法, a是数组，n表示数组大小static void mergeSort(int[] a, int n) &#123;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 mergeSortInternally(a, 0, n-1);&#125;// 递归调用函数private static void mergeSortInternally(int[] a, int p, int r) &#123; // 递归终止条件 if (p &gt;= r) return; // 取p到r之间的中间位置q,防止（p+r）的和超过int类型最大值 int q = p + (r - p)/2; // 分治递归 mergeSortInternally(a, p, q); mergeSortInternally(a, q+1, r); // 将A[p...q]和A[q+1...r]合并为A[p...r] merge(a, p, q, r);&#125;private static void merge(int[] a, int p, int q, int r) &#123; int i = p; int j = q+1; int k = 0; // 初始化变量i, j, k int[] tmp = new int[r-p+1]; // 申请一个大小跟a[p...r]一样的临时数组 while (i&lt;=q &amp;&amp; j&lt;=r) &#123; if (a[i] &lt;= a[j]) &#123; tmp[k++] = a[i++]; // i++等于i:=i+1 &#125; else &#123; tmp[k++] = a[j++]; &#125; &#125; // 判断哪个子数组中有剩余的数据 int start = i; int end = q; if (j &lt;= r) &#123; start = j; end = r; &#125; // 将剩余的数据拷贝到临时数组tmp while (start &lt;= end) &#123; tmp[k++] = a[start++]; &#125; // 将tmp中的数组拷贝回a[p...r] for (i = 0; i &lt;= r-p; ++i) &#123; a[p+i] = tmp[i]; &#125;&#125; 归并排序与快速排序的区别归并和快排用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢？1.归并排序，是先递归调用，再进行合并，合并的时候进行数据的交换。所以它是自下而上的排序方式。何为自下而上？就是先解决子问题，再解决父问题。2.快速排序，是先分区，在递归调用，分区的时候进行数据的交换。所以它是自上而下的排序方式。何为自上而下？就是先解决父问题，再解决子问题。 思考 O(n)时间复杂度内求无序数组中第K大元素，比如4，2，5，12，3这样一组数据，第3大元素是4。我们选择数组区间A[0…n-1]的最后一个元素作为pivot，对数组A[0…n-1]进行原地分区，这样数组就分成了3部分，A[0…p-1]、A[p]、A[p+1…n-1]。如果如果p+1=K，那A[p]就是要求解的元素；如果K&gt;p+1，说明第K大元素出现在A[p+1…n-1]区间，我们按照上面的思路递归地在A[p+1…n-1]这个区间查找。同理，如果K&lt;p+1，那我们就在A[0…p-1]区间查找。时间复杂度分析？答：第一次分区查找，我们需要对大小为n的数组进行分区操作，需要遍历n个元素。第二次分区查找，我们需要对大小为n/2的数组执行分区操作，需要遍历n/2个元素。依次类推，分区遍历元素的个数分别为n、n/2、n/4、n/8、n/16……直到区间缩小为1。如果把每次分区遍历的元素个数累加起来，就是等比数列求和，结果为2n-1。所以，上述解决问题的思路为O(n)。 有10个访问日志文件，每个日志文件大小约为300MB，每个文件里的日志都是按照时间戳从小到大排序的。现在需要将这10个较小的日志文件合并为1个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述任务的机器内存只有1GB，你有什么好的解决思路能快速地将这10个日志文件合并？答：先构建十条io流，分别指向十个文件，每条io流读取对应文件的第一条数据，然后比较时间戳，选择出时间戳最小的那条数据，将其写入一个新的文件，然后指向该时间戳的io流读取下一行数据，然后继续刚才的操作，比较选出最小的时间戳数据，写入新文件，io流读取下一行数据，以此类推，完成文件的合并， 这种处理方式，日志文件有n个数据就要比较n次，每次比较选出一条数据来写入，时间复杂度是O（n），空间复杂度是O（1）,几乎不占用内存。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序--上篇]]></title>
    <url>%2FNTTBlog%2F2019%2F04%2F06%2F%E6%8E%92%E5%BA%8F-%E4%B8%8A%E7%AF%87%2F</url>
    <content type="text"><![CDATA[排序方法与复杂度归类（1）几种最经典、最常用的排序方法：冒泡排序、插入排序、选择排序、快速排序、归并排序、计数排序、基数排序、桶排序。（2）复杂度归类冒泡排序、插入排序、选择排序 O(n^2)快速排序、归并排序 O(nlogn)计数排序、基数排序、桶排序 O(n) 如何分析一个“排序算法”？算法的执行效率 最好、最坏、平均情况时间复杂度。 时间复杂度的系数、常数和低阶。 比较次数，交换（或移动）次数。排序算法的稳定性 稳定性概念：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。 稳定性重要性：可针对对象的多种属性进行有优先级的排序。 举例：给电商交易系统中的“订单”排序，按照金额大小对订单数据排序，对于相同金额的订单以下单时间早晚排序。用稳定排序算法可简洁地解决。先按照下单时间给订单排序，排序完成后用稳定排序算法按照订单金额重新排序。排序算法的内存损耗原地排序算法：特指空间复杂度是O(1)的排序算法。 冒泡排序12345678910111213141516public void bubbleSort(int[] a, int n) &#123; if (n &lt;= 1) return; for (int i = 0; i &lt; n; ++i) &#123; // 提前退出冒泡循环的标志位 boolean flag = false; for (int j = 0; j &lt; n - i - 1; ++j) &#123; if (a[j] &gt; a[j+1]) &#123; // 交换 int tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; flag = true; // 表示有数据交换 &#125; &#125; if (!flag) break; // 没有数据交换，提前退出 &#125;&#125; 冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让它俩互换。稳定性：冒泡排序是稳定的排序算法。空间复杂度：冒泡排序是原地排序算法。时间复杂度： 最好情况（满有序度）：O(n)。 最坏情况（满逆序度）：O(n^2)。 平均情况：“有序度”和“逆序度”：对于一个不完全有序的数组，如4，5，6，3，2，1，有序元素对为3个（4，5），（4，6），（5，6），有序度为3，逆序度为12；对于一个完全有序的数组，如1，2，3，4，5，6，有序度就是n(n-1)/2，也就是15，称作满有序度；逆序度=满有序度-有序度；冒泡排序、插入排序交换（或移动）次数=逆序度。最好情况下初始有序度为n(n-1)/2，最坏情况下初始有序度为0，则平均初始有序度为n(n-1)/4，即交换次数为n(n-1)/4，因交换次数&lt;比较次数&lt;最坏情况时间复杂度，所以平均时间复杂度为O(n^2)。 插入排序12345678910111213141516 public void insertionSort(int[] a, int n) &#123; if (n &lt;= 1) return; for (int i = 1; i &lt; n; ++i) &#123; int value = a[i]; int j = i - 1; // 查找插入的位置 for (; j &gt;= 0; --j) &#123; if (a[j] &gt; value) &#123; a[j+1] = a[j]; // 数据移动 &#125; else &#123; break; &#125; &#125; a[j+1] = value; // 插入数据 &#125;&#125; 插入排序将数组数据分成已排序区间和未排序区间。初始已排序区间只有一个元素，即数组第一个元素。在未排序区间取出一个元素插入到已排序区间的合适位置，直到未排序区间为空。空间复杂度：插入排序是原地排序算法。时间复杂度： 最好情况：O(n)。 最坏情况：O(n^2)。 平均情况：O(n^2)（往数组中插入一个数的平均时间复杂度是O(n)，一共重复n次）。稳定性：插入排序是稳定的排序算法。 选择排序12345678910111213public static void selectSort(int[] a, int n) &#123;if(n&lt;=0) return;for(int i=0;i&lt;n;i++)&#123;int min=i;for(int j=i;j&lt;n;j++)&#123;if(a[j] &lt; a[min]) min=j;&#125;if(min != i)&#123;int temp=a[i];a[i]=a[min];a[min]=temp;&#125;&#125; 选择排序将数组分成已排序区间和未排序区间。初始已排序区间为空。每次从未排序区间中选出最小的元素插入已排序区间的末尾，直到未排序区间为空。空间复杂度：选择排序是原地排序算法。时间复杂度：（都是O(n^2)） 最好情况：O(n^2)。 最坏情况：O(n^2)。 平均情况：O(n^2)。稳定性：选择排序不是稳定的排序算法。 思考选择排序和插入排序的时间复杂度相同，都是O(n^2)，在实际的软件开发中，为什么我们更倾向于使用插入排序而不是冒泡排序算法呢？答：从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要3个赋值操作，而插入排序只需要1个，所以在对相同数组进行排序时，冒泡排序的运行时间理论上要长于插入排序。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归]]></title>
    <url>%2FNTTBlog%2F2019%2F04%2F06%2F%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[什么是递归？ 递归是一种非常高效、简洁的编码技巧，一种应用非常广泛的算法，比如DFS深度优先搜索、前中后序二叉树遍历等都是使用递归。 方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。 基本上，所有的递归问题都可以用递推公式来表示。为什么使用递归？递归的优缺点？ 优点：代码的表达力很强，写起来简洁。 缺点：空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用会耗时较多等问题。什么样的问题可以用递归解决呢？一个问题只要同时满足以下3个条件，就可以用递归来解决：1.问题的解可以分解为几个子问题的解。何为子问题？就是数据规模更小的问题。2.问题与子问题，除了数据规模不同，求解思路完全一样3.存在递归终止条件如何实现递归？递归代码编写写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。递归代码理解对于递归代码，若试图想清楚整个递和归的过程，实际上是进入了一个思维误区。那该如何理解递归代码呢？如果一个问题A可以分解为若干个子问题B、C、D，你可以假设子问题B、C、D已经解决。而且，你只需要思考问题A与子问题B、C、D两层之间的关系即可，不需要一层层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。因此，理解递归代码，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。递归常见问题及解决方案 警惕堆栈溢出：可以声明一个全局变量来控制递归的深度，从而避免堆栈溢出。 警惕重复计算：通过某种数据结构来保存已经求解过的值，从而避免重复计算。如何将递归改写为非递归代码？笼统的讲，所有的递归代码都可以改写为迭代循环的非递归写法。如何做？抽象出递推公式、初始值和边界条件，然后用迭代循环实现。我们平时调试代码喜欢使用 IDE 的单步跟踪功能，像规模比较大、递归层次很深的递归代码，几乎无法使用这种调试方式。对于递归代码，你有什么好的调试方法呢？调试递归:1.打印日志发现，递归值。2.结合条件断点进行调试。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列]]></title>
    <url>%2FNTTBlog%2F2019%2F04%2F06%2F%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[什么是队列？ 先进者先出，这就是典型的“队列”结构。 支持两个操作：入队enqueue()，放一个数据到队尾；出队dequeue()，从队头取一个元素。 所以，和栈一样，队列也是一种操作受限的线性表。 顺序队列 链式队列 循环队列确定好队空和队满的判定条件。队空：head == tail队满：(tail+1)%n=head。队列有哪些常见的应用？阻塞队列 在队列的基础上增加阻塞操作，就成了阻塞队列。 阻塞队列就是在队列为空的时候，从队头取数据会被阻塞，因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后在返回。 从上面的定义可以看出这就是一个“生产者-消费者模型”。这种基于阻塞队列实现的“生产者-消费者模型”可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了，这时生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续生产。不仅如此，基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据处理效率，比如配置几个消费者，来应对一个生产者。并发队列 在多线程的情况下，会有多个线程同时操作队列，这时就会存在线程安全问题。能够有效解决线程安全问题的队列就称为并发队列。 并发队列简单的实现就是在enqueue()、dequeue()方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或取操作。 实际上，基于数组的循环队列利用CAS原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。线程池资源枯竭是的处理 在资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。思考除了线程池这种池结构会用到队列排队请求，还有哪些类似线程池结构或者场景中会用到队列的排队请求呢？分布式应用中的消息队列，也是一种队列结构 今天讲到并发队列，关于如何实现无锁的并发队列，网上有很多讨论。对这个问题，你怎么看？考虑使用CAS实现无锁队列，则在入队前，获取tail位置，入队时比较tail是否发生变化，如果否，则允许入队，反之，本次入队失败。出队则是获取head位置，进行cas。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈]]></title>
    <url>%2FNTTBlog%2F2019%2F04%2F06%2F%E6%A0%88%2F</url>
    <content type="text"><![CDATA[什么是栈？ 后进者先出，先进者后出，这就是典型的“栈”结构。 从栈的操作特性来看，是一种“操作受限”的线性表，只允许在端插入和删除数据。为什么需要栈？栈是一种操作受限的数据结构，其操作特性用数组和链表均可实现。但，任何数据结构都是对特定应用场景的抽象，数组和链表虽然使用起来更加灵活，但却暴露了几乎所有的操作，难免会引发错误操作的风险。所以，当某个数据集合只涉及在某端插入和删除数据，且满足后进者先出，先进者后出的操作特性时，我们应该首选栈这种数据结构。栈的应用 栈在函数调用中的应用操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构，用来存储函数调用时的临时变量。每进入一个函数，就会将其中的临时变量作为栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。123456789101112131415int main() &#123; int a = 1; int ret = 0; int res = 0; ret = add(3, 5); res = a + ret; printf(&quot;%d&quot;, res); reuturn 0;&#125;int add(int x, int y) &#123; int sum = 0; sum = x + y; return sum;&#125; 栈在表达式求值中的应用（比如：34+13*9+44-12/3）利用两个栈，其中一个用来保存操作数，另一个用来保存运算符。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较，若比运算符栈顶元素优先级高，就将当前运算符压入栈，若比运算符栈顶元素的优先级低或者相同，从运算符栈中取出栈顶运算符，从操作数栈顶取出2个操作数，然后进行计算，把计算完的结果压入操作数栈，继续比较。 栈在括号匹配中的应用（比如：{}{()}）用栈保存为匹配的左括号，从左到右一次扫描字符串，当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号，如果能匹配上，则继续扫描剩下的字符串。如果扫描过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明未匹配的左括号为非法格式。 如何实现浏览器的前进后退功能？我们使用两个栈X和Y，我们把首次浏览的页面依次压如栈X，当点击后退按钮时，再依次从栈X中出栈，并将出栈的数据一次放入Y栈。当点击前进按钮时，我们依次从栈Y中取出数据，放入栈X中。当栈X中没有数据时，说明没有页面可以继续后退浏览了。当Y栈没有数据，那就说明没有页面可以点击前进浏览了。 思考我们在讲栈的应用时，讲到用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。 我们都知道，JVM 内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储 Java 中的对象。那 JVM 里面的“栈”跟我们这里说的“栈”是不是一回事呢？如果不是，那它为什么又叫作“栈”呢？内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA 插件个人常用总结]]></title>
    <url>%2FNTTBlog%2F2019%2F04%2F05%2FIDEA-%E6%8F%92%E4%BB%B6%E4%B8%AA%E4%BA%BA%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[包含idea美化 、代码的检验、热部署、Json 转换 、翻译等]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表--下篇]]></title>
    <url>%2FNTTBlog%2F2019%2F04%2F05%2F%E9%93%BE%E8%A1%A8-%E4%B8%8B%E7%AF%87%2F</url>
    <content type="text"><![CDATA[如何轻松写出正确的链表代码？理解指针或引用的含义1.含义：将某个变量（对象）赋值给指针（引用），实际上就是就是将这个变量（对象）的地址赋值给指针（引用）。2.示例：p—&gt;next = q; 表示p节点的后继指针存储了q节点的内存地址。p—&gt;next = p—&gt;next—&gt;next; 表示p节点的后继指针存储了p节点的下下个节点的内存地址。 警惕指针丢失和内存泄漏（单链表）1.插入节点在节点a和节点b之间插入节点x，b是a的下一节点，，p指针指向节点a，则造成指针丢失和内存泄漏的代码：p—&gt;next = x;x—&gt;next = p—&gt;next; 显然这会导致x节点的后继指针指向自身。正确的写法是2句代码交换顺序，即：x—&gt;next = p—&gt;next; p—&gt;next = x;2.删除节点在节点a和节点b之间删除节点b，b是a的下一节点，p指针指向节点a：p—&gt;next = p—&gt;next—&gt;next; 利用“哨兵”简化实现难度什么是“哨兵”？链表中的“哨兵”节点是解决边界问题的，不参与业务逻辑。如果我们引入“哨兵”节点，则不管链表是否为空，head指针都会指向这个“哨兵”节点。我们把这种有“哨兵”节点的链表称为带头链表，相反，没有“哨兵”节点的链表就称为不带头链表。 未引入“哨兵”的情况如果在p节点后插入一个节点，只需2行代码即可搞定：new_node—&gt;next = p—&gt;next;p—&gt;next = new_node;但，若向空链表中插入一个节点，则代码如下：if(head == null){head = new_node;}如果要删除节点p的后继节点，只需1行代码即可搞定：p—&gt;next = p—&gt;next—&gt;next;但，若是删除链表的最有一个节点（链表中只剩下这个节点），则代码如下：if(head—&gt;next == null){head = null;}从上面的情况可以看出，针对链表的插入、删除操作，需要对插入第一个节点和删除最后一个节点的情况进行特殊处理。这样代码就会显得很繁琐，所以引入“哨兵”节点来解决这个问题。 引入“哨兵”的情况“哨兵”节点不存储数据，无论链表是否为空，head指针都会指向它，作为链表的头结点始终存在。这样，插入第一个节点和插入其他节点，删除最后一个节点和删除其他节点都可以统一为相同的代码实现逻辑了。 4.“哨兵”还有哪些应用场景？哨兵最大的作用就是简化边界条件的处理。对于双向链表 L（L.head 为表头，表头有值，L.head.prev 为 NIL），L.nil 作为该链表的哨兵变量，L.nil.next 指向表头；L.nil.prev 指向表尾； 不含哨兵的链表（头）插入：LIST_INSERT(L, x) x.next = L.head if L.head != NIL L.head.prev = x L.head = x x.prev = NIL 使用哨兵之后便可以省去条件判断语句：LIST_INSERT&#39;(L, x) x.next = L.nil.next L.nil.next.prev = x L.nil.next = x x.prev = L.nil重点留意边界条件处理经常用来检查链表是否正确的边界4个边界条件： 如果链表为空时，代码是否能正常工作？ 如果链表只包含一个节点时，代码是否能正常工作？ 如果链表只包含两个节点时，代码是否能正常工作？ 代码逻辑在处理头尾节点时是否能正常工作？ 举例画图，辅助思考核心思想：释放脑容量，留更多的给逻辑思考，这样就会感觉到思路清晰很多。 多写多练，没有捷径5个常见的链表操作： 单链表反转 链表中环的检测 两个有序链表合并 删除链表倒数第n个节点 求链表的中间节点]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表--上篇]]></title>
    <url>%2FNTTBlog%2F2019%2F04%2F05%2F%E9%93%BE%E8%A1%A8-%E4%B8%8A%E7%AF%87%2F</url>
    <content type="text"><![CDATA[什么是链表？ 和数组一样，链表也是一种线性表。 从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构。 链表中的每一个内存块被称为节点Node。节点除了存储数据外，还需记录链上下一个节点的地址，即后继指针next。为什么使用链表？即链表的特点1.插入、删除数据效率高O(1)级别（只需更改指针指向即可），随机访问效率低O(n)级别（需要从链头至链尾进行遍历）。2.和数组相比，内存空间消耗更大，因为每个存储数据的节点都需要额外的空间存储后继指针。常用链表：单链表、循环链表和双向链表单链表 每个节点只包含一个指针，即后继指针。 单链表有两个特殊的节点，即首节点和尾节点。为什么特殊？用首节点地址表示整条链表，尾节点的后继指针指向空地址null。 性能特点：插入和删除节点的时间复杂度为O（1），查找的时间复杂度为O(n)。循环链表 除了尾节点的后继指针指向首节点的地址外均与单链表一致。 适用于存储有循环特点的数据，比如约瑟夫问题。双向链表 节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针prev）和下一个节点地址（后继指针next）。 首节点的前驱指针prev和尾节点的后继指针均指向空地址。 性能特点：和单链表相比，存储相同的数据，需要消耗更多的存储空间。插入、删除操作比单链表效率更高O(1)级别。以删除操作为例，删除操作分为2种情况：给定数据值删除对应节点和给定节点地址删除节点。对于前一种情况，单链表和双向链表都需要从头到尾进行遍历从而找到对应节点进行删除，时间复杂度为O(n)。对于第二种情况，要进行删除操作必须找到前驱节点，单链表需要从头到尾进行遍历直到p-&gt;next = q，时间复杂度为O(n)，而双向链表可以直接找到前驱节点，时间复杂度为O(1)。对于一个有序链表，双向链表的按值查询效率要比单链表高一些。因为我们可以记录上次查找的位置p，每一次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。双向循环链表：首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点。选择数组还是链表？插入、删除和随机访问的时间复杂度数组：插入、删除的时间复杂度是O(n)，随机访问的时间复杂度是O(1)。链表：插入、删除的时间复杂度是O(1)，随机访问的时间复杂端是O(n)。数组缺点 若申请内存空间很大，比如100M，但若内存空间没有100M的连续空间时，则会申请失败，尽管内存可用空间超过100M。 大小固定，若存储空间不足，需进行扩容，一旦扩容就要进行数据复制，而这时非常费时的。链表缺点 内存空间消耗更大，因为需要额外的空间存储指针信息。 对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，还可能会造成频繁的GC（自动垃圾回收器）操作。如何选择？数组简单易用，在实现上使用连续的内存空间，可以借助CPU的缓冲机制预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读。如果代码对内存的使用非常苛刻，那数组就更适合。 如何实现LRU缓存淘汰算法?什么是缓存？缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。 为什么使用缓存淘汰策略？即缓存的特点缓存的大小是有限的，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？就需要用到缓存淘汰策略。 什么是缓存淘汰策略？指的是当缓存被用满时清理数据的优先顺序。 有哪些缓存淘汰策略？常见的3种包括先进先出策略FIFO（First In，First Out）、最少使用策略LFU（Least Frenquently Used）、最近最少使用策略LRU（Least Recently Used）。 链表实现LRU缓存淘汰策略当访问的数据没有存储在缓存的链表中时，直接将数据插入链表表头，时间复杂度为O(1)；当访问的数据存在于存储的链表中时，将该数据对应的节点，插入到链表表头,时间复杂度为O(n)。如果缓存被占满，则从链表尾部的数据开始清理，时间复杂度为O(1)。 数组实现LRU缓存淘汰策略用一个数组来存储数据，给每一个数据项标记一个访问时间戳，每次插入新数据项的时候，先把数组中存在的数据项的时间戳自增，并将新数据项的时间戳置为0并插入到数组中。每次访问数组中的数据项的时候，将被访问的数据项的时间戳置为0。当数组空间已满时，将时间戳最大的数据项淘汰。 利用链表和hashmap实现LRU缓存淘汰策略当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则把该节点移到链表头部，如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节点删除即可。在访问数据的时候，如果数据项在链表中存在，则把该节点移到链表头部，否则返回-1。这样一来在链表尾部的节点就是最近最久未访问的数据项。 设计思想时空替换思想：“用空间换时间” 与 “用时间换空间”当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高，时间复杂度小相对较低的算法和数据结构，缓存就是空间换时间的例子。如果内存比较紧缺，比如代码跑在手机或者单片机上，这时，就要反过来用时间换空间的思路。 如何判断一个字符串是否是回文字符串的问题。思路：1 快慢指针定位中间节点2 从中间节点对后半部分逆序3 前后半部分比较，判断是否为回文4 后半部分逆序复原时间复杂度On, 空间复杂度O1]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组]]></title>
    <url>%2FNTTBlog%2F2019%2F04%2F05%2F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组数组如何实现随机访问 数组是一种线性数据结构，用连续的存储空间存储相同类型数据 线性表：数组、链表、队列、栈 非线性表：树 图 连续的内存空间、相同的数据，所以数组可以随机访问，但对数组进行删除插入，为了保证数组的连续性，就要做大量的数据搬移工作数组如何实现下标随机访问。 引入数组再内存种的分配图，得出寻址公式 a[i]_address = base_address + i * data_type_size 纠正数组和链表的错误认识。数组的查找操作时间复杂度并不是O(1)。 即便是排好的数组，用二分查找，时间复杂度也是O（logn）。 正确表述：数组支持随机访问，根据下标随机访问的时间复杂度为O（1） 低效的插入和删除 插入：从最好O(1) 最坏O(n) 平均O(n) 插入：数组若无序，插入新的元素时，可以将第K个位置元素移动到数组末尾，把心的元素，插入到第k个位置，此处复杂度为O(1)。作者举例说明 删除：从最好O(1) 最坏O(n) 平均O(n) 多次删除集中在一起，提高删除效率记录下已经被删除的数据，每次的删除操作并不是搬移数据，只是记录数据已经被删除，当数组没有更多的存储空间时，再触发一次真正的删除操作。即JVM标记清除垃圾回收算法。警惕数组的访问越界问题用C语言循环越界访问的例子说明访问越界的bug。此例在《C陷阱与缺陷》出现过，很惭愧，看过但是现在也只有一丢丢印象。翻了下书，替作者加上一句话：如果用来编译这段程序的编译器按照内存地址递减的方式给变量分配内存，那么内存中的i将会被置为0，则为死循环永远出不去。容器能否完全替代数组相比于数字，java中的ArrayList封装了数组的很多操作，并支持动态扩容。一旦超过村塾容量，扩容时比较耗内存，因为涉及到内存申请和数据搬移。数组适合的场景： Java ArrayList 的使用涉及装箱拆箱，有一定的性能损耗，如果特别管柱性能，可以考虑数组 若数据大小事先已知，并且涉及的数据操作非常简单，可以使用数组 表示多维数组时，数组往往更加直观。 业务开发容器即可，底层开发，如网络框架，性能优化。选择数组。解答开篇问题 从偏移角度理解a[0] 0为偏移量，如果从1计数，会多出K-1。增加cpu负担。为什么循环要写成for(int i = 0;i&lt;3;i++) 而不是for(int i = 0 ;i&lt;=2;i++)。第一个直接就可以算出3-0 = 3 有三个数据，而后者 2-0+1个数据，多出1个加法运算，很恼火。 也有一定的历史原因课后思考大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有 GC ROOTS，将所有 GC ROOTS 可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。 不足：1.效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效。2.空间问题。会产生不连续的内存空间碎片。 二维数组内存寻址： 对于 m * n 的数组，a [ i ][ j ] (i &lt; m,j &lt; n)的地址为： address = base_address + ( i n + j) type_size 另外，对于数组访问越界造成无限循环，我理解是编译器的问题，对于不同的编译器，在内存分配时，会按照内存地址递增或递减的方式进行分配。老师的程序，如果是内存地址递减的方式，就会造成无限循环。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复杂度分析--下篇]]></title>
    <url>%2FNTTBlog%2F2019%2F04%2F05%2F%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[浅析最好、最坏、平均、均摊时间复杂度最好情况时间复杂度、在最理想的情况下，执行这段代码的时间复杂度 最坏情况时间复杂度、在最糟糕的情况下，执行这段代码的时间复杂度 平均情况时间复杂度、最好与最坏是在极端情况下发生的，平均情况复杂度引入了概率，所以也叫加权平均时间复杂度或者期望时间复杂度。如出现n次情况，将出现n次中每次情况乘以每次情况出现的概率在相加，除以n，再去常量就可以得到平均时间复杂度。 均摊时间复杂度在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。 举个荔枝：今天你准备去老王家拜访下，可惜老王的爱人叫他去打个酱油，她告诉你说她限时n分钟🕒给他去买。那么你想着以他家到楼下小卖部来回最多一分钟，那么 “最好的情况”就是你只用等他一分钟。那么也有可能遇到突发情况，比如说电梯人多吖，路上摔了一胶，天知道他去干了什么，用了n分钟，没办法👐，主上有令，n分钟限时，那这就是“最坏的情况”。难点，平均时间复杂度 就是他有可能是第1.2.3…n，中的某个分钟回来，那平均就是1+2+3+…n/n，把 所有可能出现的情况的时间复杂度 相加除以 情况数 。均摊的话就是把花时间多的分给花时间少的，得到一个中间值，所以说这就会和平均混淆，个人觉得主要还是概念不同。假如n是10分钟，那么9分钟分4分钟到1分钟那，8分3给2…，那均摊下来就是5分钟.]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复杂度分析--上篇]]></title>
    <url>%2FNTTBlog%2F2019%2F04%2F05%2F%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8A%E7%AF%87%2F</url>
    <content type="text"><![CDATA[什么是复杂度分析？ 数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。 因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。 分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称4.为复杂度。 复杂度描述的是算法执行时间（或占用如何分析、统计算法的执行效率和资源消耗空间）与数据规模的增长关系。为什么要进行复杂度分析？ 和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。 掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。如何进行复杂度分析？大O表示法 来源 算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。 特点以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。 时间复杂度分析分析法则 只关注循环执行次数最多的一段代码–单段代码看高频：比如循环。 加法法则：总复杂度等于量级最大的那段代码的复杂度–比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积–嵌套代码求乘积：比如递归、多重循环等 多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。几种常见时间复杂度实例分析 总结了一下，这些复杂度量级几乎涵盖了你今后可以接触的所有代码的复杂度量级。多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，O(1)（常数阶）–一般情况下，只要算法中不存在循环语句、递归语句、即使有成千上万行的代码，其时间复杂度也是Ο(1)。、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）–比如，归并排序、快速排序O(n^2)（平方阶）、O(n^3)（立方阶）非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，O(2^n)（指数阶）、O(n!)（阶乘阶）常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。 空间复杂度分析表示算法的执行时间与数据规模之间的增长关系。常见的空间复杂度就是 O(1)、O(n)、O(n2 )。 如何掌握好复杂度分析方法？复杂度分析关键在于多练，所谓孰能生巧。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2FNTTBlog%2F2019%2F03%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
